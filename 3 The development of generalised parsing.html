<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3. The development of generalised parsing &mdash; Generalised LR parsing algorithms  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/documentation_options.js?v=5929fcd5"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="4. Generalised LR parsing" href="4%20Generalised%20LR%20parsing.html" />
    <link rel="prev" title="2. Recognition and parsing" href="2%20%20Recognition%20and%20parsing.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Generalised LR parsing algorithms
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1%20Introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="2%20%20Recognition%20and%20parsing.html">2. Recognition and parsing</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">3. The development of generalised parsing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">3.1 Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#unger-s-method">3.2 Unger’s method</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-cyk-algorithm">The CYK algorithm</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#summary">3.4 Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="4%20Generalised%20LR%20parsing.html">4. Generalised LR parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="5%20Right%20Nulled%20Generalised%20LR%20parsing.html">5. Right Nulled Generalised LR parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="6%20Binary%20Right%20Nulled%20Generalised%20LR%20parsing.html">6.Binary Right Nulled Generalised LR parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="7%20Reduction%20Incorporated%20Generalised%20LR%20parsing.html">7.Reduction Incorporated Generalised LR parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="8%20Other%20approaches%20to%20generalised%20parsing.html">8 Other approaches to generalised parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="9%20Some%20generalised%20parser%20generators.html">9. Some generalised parser generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="10%20Experimental%20investigation.html">10. Experimental investigation</a></li>
<li class="toctree-l1"><a class="reference internal" href="11%20Concluding%20remarks.html">11. Concluding remarks</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Generalised LR parsing algorithms</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">3. The development of generalised parsing</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/3 The development of generalised parsing.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="the-development-of-generalised-parsing">
<h1>3. The development of generalised parsing<a class="headerlink" href="#the-development-of-generalised-parsing" title="Link to this heading">¶</a></h1>
<p>The field of parsing has been the focus of research for over 40 years, but we still have not found the holy grail of the parsing world - a linear time general parsing algorithm. We do not even know if it is possible to parse all context-free languages in linear time. This chapter is a tour of the major developments of generalised parsing and a discussion of the links between the different algorithms.</p>
<section id="overview">
<h2>3.1 Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h2>
<p>There are many different parsing algorithms described in the literature. By tracing their development, valuable insights can be gained. Techniques that may at first appear to be different, can often be related. For example, the CYK algorithm [CS70, You67, KT69] is the unification of several independently developed algorithms. Furthermore, the CYK algorithm has been shown [GH76] to be equivalent to the algorithm developed by Earley [Ear68]. This opinion has been voiced before by Dick Grune [GJ90],</p>
<p>When we consult the extensive literature on parsing techniques, we seem to find dozens of them, yet there are only two techniques to do parsing; all the rest is technical detail and embellishment.</p>
<p>Many algorithms have been developed in response to limitations of, or to incorporate optimisations of, existing techniques. For example, GLR algorithms, initially described by Tomita [Tom86], are extensions of the standard LR algorithm. As we shall discuss in later chapters, Nozohoor-Farshi [NF91] removes the limitations of Tomita’s algorithm, whilst Aycock and Horspool [AH99] incorporate Tomita’s efficient data-structure to optimise a separate algorithm.</p>
<p>Recently, approaches that were previously deemed too inefficient are becoming practical solely due to the rapid increase of computing power. Tomita’s algorithm was developed in the context of natural language parsing where input strings are typically short. At that time, the use of his algorithm for parsing programming languages was considered infeasible. However, as we shall see in Chapter 9, several commonly used tools implement variants of Tomita’s algorithm.</p>
<p>This chapter presents an overview of the relationships between different generalised parsing techniques and provides two of the most straight-forward algorithms - Unger’s algorithm and the CYK algorithm.</p>
<p>– Unger’s algorithm and the CYK algorithm.
The diagram in Figure 3.1 lists several algorithms by the names of its developers, grouping similar approaches together in boxes. Solid arrows between algorithms indicate an extension or improvement made, while dotted arrows lead to the implementation of a specific algorithm.</p>
<p>The box on the top left of Figure 3.1 shows two early general context-free parsing algorithms. The technique described by Irons [Iro61] has been credited as being the “first fully described parser” [GJ90]. It is a full backtracking recursive-descent, left-corner parser that displays exponential worst case time complexity.</p>
<p>The second approach, attributed to Unger [Ung68], is a straightforward general parsing algorithm that has been “anonymously used” [GJ90] by many other algorithms. Although other algorithms, like CYK, are more efficient and have had more attention, Unger’s algorithm has been modified by Sheil to achieve the same performance [She76]. It has the advantage of being extremely easy to understand and as such we give an overview of the technique in this chapter.</p>
<p>The existing (general) parsing algorithms were too inefficient to be used as programming language parsers. As a consequence of this inefficiency, two approaches were developed that considered only the deterministic subclass of the context-free grammars.</p>
<p>The LL grammars can be used to describe the syntax of a useful class of deterministic context-free grammars which include the syntax of many programming languages. Lewis and Stearns [AU73] are considered to be major contributors to the development of the top-down LL parsing technique. Although LL parsers are efficient (linear time) they do not accept left recursive grammars. It is often useful to define programming language grammars using left recursion and whilst standard removal algorithms exist [AU73], the structure, and potentially the semantics, of the grammar are altered by the transformation. However, the technique is still popular because it is fairly straightforward to generate LL parsers by hand.</p>
<p>At about the same time, Knuth developed his LR parsing algorithm [Knu65], a bottom-up approach (described in Chapter 2) which achieves linear time parsing of a context-free subclass larger than the class of LL grammars. In particular, they can cope with deterministic left recursive grammars. However, the requiredFigure 3.1: The development of general context-free parsing. Algorithms are grouped in boxes by contributing authors. Solid arrows indicate an extension or improvement made, while dotted arrows lead to the implementation of a specific algorithm.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310072347357.png" /></p>
<p>automata were too large to be of practical use. Although smaller automata were developed [1, 2], generating them by hand was a difficult and laborious task. The development of parser generators, in particular Yacc [15], made LR parsing a popular approach for programming language parsers.</p>
<p>Whilst the programming language community focused on improving the efficiency of a useful (restricted) class of context-free grammars, the natural language processing community required more efficient parsers for all context-free grammars. The CYK algorithm was independently developed by Cocke [10], Younger [14] and Kasami [12] in the 1960’s. The algorithm parses all context-free grammars in worst-case cubic time, but relies on grammars being in two-form. We discuss the CYK algorithm in more detail in Section 3.3 of this chapter.</p>
<p>Another technique developed later by Earley [1] performs better in some cases but has a similar worst case complexity to CYK. Earley’s approach is a directional, bottom-up technique. In this respect it appears to be very different to CYK, but it has been shown [13] that the two algorithms are in fact closely related. We discuss Earley’s algorithm in more detail in Chapter 8.</p>
<p>Many programming language developers were content with efficiently parsing a subset of the context-free grammars and new programming languages were designed with grammars that were ‘easy’ to parse. It was not until the 1980’s that an interest in generalised parsing resurfaced in the form of Tomita’s GLR parser [15]. Tomita’s algorithm extends the standard LR parsing technique to parse a larger class of grammars. Although his algorithm fails to terminate for certain grammars, it parses all LR grammars in linear time. Corrected versions of Tomita’s algorithm have been given by Farshi [12], Scott &amp; Johnstone [13] and Nederhof &amp; Sarbo [14]. We discuss these approaches in Chapters 4, 5 and 8 respectively.</p>
<p>There have been many attempts to speed up the performance of GLR parsers. A novel technique presented by Aycock and Horspool improves the efficiency through the reduction of stack activity [1]. Unfortunately their technique fails to work for certain grammars. However, an extension of their approach has been given by Scott and Johnstone [13] which successfully parses all context-free grammars. We discuss these algorithms in Chapter 7.</p>
<p>In the remainder of this chapter we shall outline two important developments in the history of parsing. They have no immediate impact on the GLR-style algorithms that are the main topic of this thesis and we shall not need them later. However, we include them for completeness.</p>
</section>
<section id="unger-s-method">
<h2>3.2 Unger’s method<a class="headerlink" href="#unger-s-method" title="Link to this heading">¶</a></h2>
<p>One of the earliest and most straightforward general parsing algorithms is the technique developed by Unger [10]. It has the advantage of being extremely easy to understand and as such we present an example parse in detail.</p>
<p><strong>Example - recognition using Unger’s method</strong></p>
<p>Unger’s method works by trying to partition the input string so that it can be derived from the start rule. For example consider Grammar 3.1.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310102305699.png" /></p>
<p>We start off by partitioning the input string for the right hand side of the start symbol.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310072348010.png" /></p>
<p>The non-terminal <span class="math notranslate nohighlight">\(S\)</span> can be replaced by one of 3 alternates. We start off with the first alternate and partition the input as follows.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310072348550.png" /></p>
<p>This method of partitioning can easily get out of hand if the right hand side of rules and the input string are large. Unger provided some optimisations that limited the number of partitions that need to be kept. Any partitions that do not match the terminals in the input string can be removed. This leaves us with only one partition that can possibly lead to a derivation of the input string. For example, since the non-terminals A and B cannot be extended any further, we focus on the non-terminal S, which has three alternates that can potentially be used to derive <span class="math notranslate nohighlight">\(bca\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310072348365.png" /></p>
<p>Trying the first alternate we see that it cannot be used because the non-terminals A and B do not derive the terminal they have been partitioned with.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310072348861.png" /></p>
<p>Trying the next alternate, we have a success as all the non-terminals are able to derive the terminals in one step.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310072348634.png" /></p>
<p>This leads us to the following (unique) derivation of the input string.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310102305692.png" /></p>
<p>A na ̈ıve implementation of Unger’s algorithm has exponential time complexity, which limits its use to trivial examples. The addition of a well-formed substring table dramatically improves the efficiency, the complexity becomes <span class="math notranslate nohighlight">\(O(n^{k+1})\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the length of the input string and <span class="math notranslate nohighlight">\(k\)</span> is the maximum length of a rule’s right hand side (see [1] for more details).</p>
<section id="the-cyk-algorithm">
<h3>The CYK algorithm<a class="headerlink" href="#the-cyk-algorithm" title="Link to this heading">¶</a></h3>
<p>The CYK algorithm is a general recognition algorithm with <span class="math notranslate nohighlight">\(O(n^{3})\)</span> worst case time complexity for all context-free grammars in Chomsky Normal Form (CNF). A context-free grammar is said to be in CNF if every rule is of the form <span class="math notranslate nohighlight">\(A::=BC\)</span>, or <span class="math notranslate nohighlight">\(A::=a\)</span>, or <span class="math notranslate nohighlight">\(S::=\epsilon\)</span>, where <span class="math notranslate nohighlight">\(ABC\)</span> are non-terminals and <span class="math notranslate nohighlight">\(S\)</span> is the grammar’s start symbol.</p>
<p>The CYK algorithm uses an <span class="math notranslate nohighlight">\((n+1)(n+1)\)</span> triangular matrix, where <span class="math notranslate nohighlight">\(n\)</span> is the length of the input string, to determine whether a string is in the language. Each cell contains a set of non-terminals that are used in a derivation. In [1] the matrix is constructed in the top right diagonal instead of the top left as is done by Cocke, Younger and Kasami. Both algorithms are equivalent, but Graham’s description is easier to compare against other chart parsers, like Earley’s algorithm. The formal specification of the recognition matrix construction algorithm, taken from [1], is as follows.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080014370.png" />
To demonstrate the recognition of a string using the CYK algorithm we trace the construction process of the recognition matrix for the string <span class="math notranslate nohighlight">\(abcab\)</span> in Grammar 3.1. Since the CYK algorithm requires grammars to be in CNF we use the CNF conversion algorithm presented in [1] to transform Grammar 3.1 to Grammar 3.2.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310102304490.png" /></p>
<p>We begin the parse of the string <span class="math notranslate nohighlight">\(abcab\)</span> by filling the <em>superdiagonal stripe</em>[1] of the matrix from the top left to the bottom right of the matrix with non-terminals that directly derive the consecutive symbols of the input string.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080017715.png" /></p>
<p>Once the construction of the recognition matrix is complete, we check the entry in the top right cell. If it contains the non-terminal on the right hand side of the start rule then the string is accepted. In our example parse we can see that the string <span class="math notranslate nohighlight">\(abcab\)</span> is in the language of Grammar 3.2.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080017043.png" /></p>
<p>Once the construction of the recognition matrix is complete, we check the entry in the top right cell. If it contains the non-terminal on the right hand side of the start rule then the string is accepted. In our example parse we can see that the string <span class="math notranslate nohighlight">\(abcab\)</span> is in the language of Grammar 3.2.</p>
</section>
</section>
<section id="summary">
<h2>3.4 Summary<a class="headerlink" href="#summary" title="Link to this heading">¶</a></h2>
<p>In this chapter we have discussed some of the major developments of generalised parsing techniques. We also briefly discussed Unger’s approach and the <span class="math notranslate nohighlight">\(CYK\)</span> recognition algorithm.</p>
<p>In the next chapter we discuss, in detail, Tomita’s <span class="math notranslate nohighlight">\(GLR\)</span> parsing algorithm and the extensions due to Farshi and Rekers.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="2%20%20Recognition%20and%20parsing.html" class="btn btn-neutral float-left" title="2. Recognition and parsing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="4%20Generalised%20LR%20parsing.html" class="btn btn-neutral float-right" title="4. Generalised LR parsing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, xrtero.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>