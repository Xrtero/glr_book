<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>6.Binary Right Nulled Generalised LR parsing &mdash; Generalised LR parsing algorithms  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="canonical" href="https://www.xrtero.com/book/glr/6 Binary Right Nulled Generalised LR parsing.html" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=b3ba4146"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="7.Reduction Incorporated Generalised LR parsing" href="7%20Reduction%20Incorporated%20Generalised%20LR%20parsing.html" />
    <link rel="prev" title="5. Right Nulled Generalised LR parsing" href="5%20Right%20Nulled%20Generalised%20LR%20parsing.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Generalised LR parsing algorithms
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1%20Introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="2%20%20Recognition%20and%20parsing.html">2. Recognition and parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="3%20The%20development%20of%20generalised%20parsing.html">3. The development of generalised parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="4%20Generalised%20LR%20parsing.html">4. Generalised LR parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="5%20Right%20Nulled%20Generalised%20LR%20parsing.html">5. Right Nulled Generalised LR parsing</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">6.Binary Right Nulled Generalised LR parsing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-worst-case-complexity-of-glr-recognisers">6.1 The worst case complexity of GLR recognisers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example-recognition-in-o-n-4-time">Example - Recognition in <span class="math notranslate nohighlight">\(O(n^{4})\)</span> time</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#achieving-cubic-time-complexity-by-factoring-the-grammar">6.2 Achieving cubic time complexity by factoring the grammar</a></li>
<li class="toctree-l2"><a class="reference internal" href="#achieving-cubic-time-complexity-by-modifying-the-parse-table">6.3 Achieving cubic time complexity by modifying the parse table</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-brnglr-recognition-algorithm">6.4 The BRNGLR recognition algorithm</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#brnglr-recogniser">BRNGLR recogniser</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#performing-on-the-fly-reduction-path-factorisation">6.5 Performing ‘on-the-fly’ reduction path factorisation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#brnglr-on-the-fly-recogniser"><strong>BRNGLR ‘on-the-fly’ recogniser</strong></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#example-on-the-fly-recognition-in-o-n-3-time">Example - ‘on-the-fly’ recognition in <span class="math notranslate nohighlight">\(O(n^{3})\)</span> time</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#glr-parsing-in-at-most-cubic-time">6.6 GLR parsing in at most cubic time</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#brnglr-parser">BRNGLR parser</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-parsing-in-o-n-3-time">Example - parsing in <span class="math notranslate nohighlight">\(O(n^{3})\)</span> time</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#packing-of-bookkeeping-sppf-nodes">6.7 Packing of bookkeeping SPPF nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example-how-to-pack-bookkeeping-sppf-nodes">Example - how to pack bookkeeping SPPF nodes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#summary">6.8 Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="7%20Reduction%20Incorporated%20Generalised%20LR%20parsing.html">7.Reduction Incorporated Generalised LR parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="8%20Other%20approaches%20to%20generalised%20parsing.html">8 Other approaches to generalised parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="9%20Some%20generalised%20parser%20generators.html">9. Some generalised parser generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="10%20Experimental%20investigation.html">10. Experimental investigation</a></li>
<li class="toctree-l1"><a class="reference internal" href="11%20Concluding%20remarks.html">11. Concluding remarks</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Generalised LR parsing algorithms</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">6.Binary Right Nulled Generalised LR parsing</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/6 Binary Right Nulled Generalised LR parsing.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="binary-right-nulled-generalised-lr-parsing">
<h1>6.Binary Right Nulled Generalised LR parsing<a class="headerlink" href="#binary-right-nulled-generalised-lr-parsing" title="Permalink to this heading">¶</a></h1>
<p>Despite the fact that general context-free parsing is a mature field in Computer Science, its worst case complexity is still unknown. The algorithm with the best asymptotic time complexity to date is presented in [25] by Valiant. His approach uses Boolean matrix multiplication (BMM) to construct a recognition matrix that displays the complexity of the associated BMM algorithm. Since publication of Valiant’s paper, more efficient BMM algorithms have been developed. The algorithm with currently the lowest asymptotic complexity displays <span class="math notranslate nohighlight">\(O(n^{2.376})\)</span> for <span class="math notranslate nohighlight">\(n\times n\)</span> matrices [13, 14].</p>
<p>Although the approach taken by Valiant is unlikely to be used in practice, because of the high constant overheads, it was an important step toward understanding more about the complexity of general context-free parsers. A related result has been presented by Lee which maps a context-free parser with <span class="math notranslate nohighlight">\(O(n^{3-\epsilon})\)</span> complexity to an algorithm to multiply two <span class="math notranslate nohighlight">\(n\times n\)</span> Boolean matrices in <span class="math notranslate nohighlight">\(O(n^{3-(\epsilon/3)})\)</span> time. A side effect of this work has led to the hypothesis that ‘practical parsers running in significantly lower than cubic time are unlikely to exist’ [16]. Although this analysis does suggest that linear time parsers are unlikely to exist, it does not preclude quadratic algorithms from being developed.</p>
<p>Two other general parsing algorithms that have been used in practice are the CYK and Earley algorithms. Both display cubic worst case complexity, although the CYK algorithm requires grammars to be transformed to CNF before parsing. Unfortunately this complexity is still too high for certain applications; most programming languages have largely deterministic grammars which can be parsed by linear parsers. The GLR algorithm first developed by Tomita, provides a general parsing algorithm that takes advantage of the efficiency of the deterministic LR parsers. Unfortunately these algorithms display unbounded polynomial time and space complexity [15].</p>
<p>This chapter presents an algorithm which is based on the RNGLR algorithmdescribed in Chapter 5, but which has a worst case complexity of <span class="math notranslate nohighlight">\(O(n^{3})\)</span> without requiring any transformations to be done to the grammar.</p>
<section id="the-worst-case-complexity-of-glr-recognisers">
<h2>6.1 The worst case complexity of GLR recognisers<a class="headerlink" href="#the-worst-case-complexity-of-glr-recognisers" title="Permalink to this heading">¶</a></h2>
<p>In Chapter 2 we examined the operation of a standard bottom-up shift reduce parser. Recall that such a parser works by using a stack to collect symbols of a sentential form and then when it recognises a handle, of length <span class="math notranslate nohighlight">\(m\)</span> say, it pops the <span class="math notranslate nohighlight">\(m\)</span> symbols off the stack and pushes on the left hand non-terminal of the corresponding rule. An important feature of such shift reduce parsers is that it is not necessary to examine the symbols on the stack before they are popped. The associated automaton guarantees that when a reduction for a rule <span class="math notranslate nohighlight">\(A::=\beta\)</span> is performed, the top <span class="math notranslate nohighlight">\(m\)</span> symbols on the stack are equal to <span class="math notranslate nohighlight">\(\beta\)</span>. Implementations of such parsers exploit this property and perform reductions in unit time by simply decrementing the stack pointer. In comparison, general parsing algorithms that extend such parsers cannot perform reductions as efficiently.</p>
<p>It is well known that the worst case time complexity of Tomita’s GLR parser is <span class="math notranslate nohighlight">\(O(n^{M+1})\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the length of the input string and <span class="math notranslate nohighlight">\(M\)</span> is the length of the longest grammar rule [15]. Although it is not entirely surprising, it is somewhat disappointing that the recogniser displays the same complexity, especially since both the Earley and CYK recognisers are cubic in the worst case. In this section we shall explain why the RNGLR recogniser is worse than cubic.</p>
<p>Roughly, when a GLR parser reaches a non-deterministic point in the automaton, the stack is split and both parses are followed. If the separate stacks then have a common stack top once again, the stacks are merged. This merging of stacks bounds the size of the GSS to at most <span class="math notranslate nohighlight">\((n+1)\times H\)</span> nodes, where <span class="math notranslate nohighlight">\(n\)</span> is the length of the input string and <span class="math notranslate nohighlight">\(H\)</span> is the number of states in the automaton. However, because the different stacks are now combined into one structure a reduce action can be applied down several paths from one node. Unlike the standard shift reduce parser we are not able to simply decrement a stack pointer, we need to perform a search.</p>
<p>It is possible for a state in level <span class="math notranslate nohighlight">\(i\)</span> to have edges going back to states in every other level <span class="math notranslate nohighlight">\(j\)</span>, where <span class="math notranslate nohighlight">\(0\leq j\leq i\)</span>. Since a node in the GSS can have <span class="math notranslate nohighlight">\(H\times(i+1)\)</span> edges, <span class="math notranslate nohighlight">\(i^{m}\)</span> paths may need to be explored for any reduction of length <span class="math notranslate nohighlight">\(m+1\)</span> that is performed. This results in such algorithms displaying <span class="math notranslate nohighlight">\(O(n^{m+1})\)</span> time complexity. Although we will not prove this here, we shall describe a grammar and an example string that illustrate the properties which trigger quartic behaviour in the RNGLR algorithm. Clearly this is sufficient to show that the RNGLR algorithm is not cubic.</p>
<section id="example-recognition-in-o-n-4-time">
<h3>Example - Recognition in <span class="math notranslate nohighlight">\(O(n^{4})\)</span> time<a class="headerlink" href="#example-recognition-in-o-n-4-time" title="Permalink to this heading">¶</a></h3>
<p>Consider Grammar 6.1, its LR(1) DFA in Figure 6.1 and the associated RN parse table <span class="math notranslate nohighlight">\(\mathcal{T}\)</span> in Table 6.1.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080524733.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080524027.png" /></p>
<p>We can illustrate the properties that cause the RNGLR algorithm to have at least <span class="math notranslate nohighlight">\(O(n^{4})\)</span> time complexity, by parsing the string <span class="math notranslate nohighlight">\(bbbbb\)</span>. We begin by creating the node <span class="math notranslate nohighlight">\(v_{0}\)</span> labelled with the start state of the DFA. The shift action <span class="math notranslate nohighlight">\(p2\)</span> is the only element in <span class="math notranslate nohighlight">\(\mathcal{T}(0,b)\)</span>, so we perform the shift and create the new node <span class="math notranslate nohighlight">\(v_{1}\)</span> labelled <span class="math notranslate nohighlight">\(2\)</span>. As there is the reduce action <span class="math notranslate nohighlight">\(r(S,1)\)</span> in <span class="math notranslate nohighlight">\(\mathcal{T}(2,b)\)</span>, <span class="math notranslate nohighlight">\((v_{0},S,1)\)</span> is added to the set <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>. When <span class="math notranslate nohighlight">\((v_{0},S,1)\)</span> is removed from <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>, the node <span class="math notranslate nohighlight">\(v_{2}\)</span> labelled <span class="math notranslate nohighlight">\(1\)</span> is created.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080525127.png" /></p>
<p>Processing <span class="math notranslate nohighlight">\(v_{2}\)</span> we find that the shift <span class="math notranslate nohighlight">\(p2\)</span> is the only action in <span class="math notranslate nohighlight">\(\mathcal{T}(0,b)\)</span> so we create the node <span class="math notranslate nohighlight">\(v_{3}\)</span> labelled <span class="math notranslate nohighlight">\(2\)</span> in the next level and add <span class="math notranslate nohighlight">\((v_{2},1)\)</span> since <span class="math notranslate nohighlight">\(r(S,1)\)</span> is in <span class="math notranslate nohighlight">\(\mathcal{T}(2,b)\)</span>. By performing the reduce in <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> we create node <span class="math notranslate nohighlight">\(v_{4}\)</span> labelled <span class="math notranslate nohighlight">\(3\)</span> and the edge from <span class="math notranslate nohighlight">\(v_{4}\)</span> to <span class="math notranslate nohighlight">\(v_{2}\)</span>. Examining the entry in <span class="math notranslate nohighlight">\(\mathcal{T}(3,b)\)</span> we find that there is a shift/reduce conflict with actions <span class="math notranslate nohighlight">\(p2/r(S,2)\)</span>. We add the actions to the sets <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> respectively. Performing the reduction in <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> we create <span class="math notranslate nohighlight">\(v_{5}\)</span> with an edge to <span class="math notranslate nohighlight">\(v_{0}\)</span> and then add <span class="math notranslate nohighlight">\((v_{5},S,2)\)</span> to <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080525609.png" />
Once the shifts have been removed and processed from the set <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span>, the new node <span class="math notranslate nohighlight">\(v_{6}\)</span> labelled <span class="math notranslate nohighlight">\(2\)</span> has been created in level <span class="math notranslate nohighlight">\(3\)</span>, and <span class="math notranslate nohighlight">\((v_{4},S,1)\)</span> and <span class="math notranslate nohighlight">\((v_{5},S,1)\)</span> are added to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> because of the reduce action in <span class="math notranslate nohighlight">\(\mathcal{T}(2,b)\)</span>. When both the reductions are done the nodes <span class="math notranslate nohighlight">\(v_{7}\)</span> and <span class="math notranslate nohighlight">\(v_{8}\)</span>, labelled <span class="math notranslate nohighlight">\(4\)</span> and <span class="math notranslate nohighlight">\(3\)</span> respectively, are created along with their associated edges from <span class="math notranslate nohighlight">\(v_{7}\)</span> to <span class="math notranslate nohighlight">\(v_{4}\)</span> and <span class="math notranslate nohighlight">\(v_{8}\)</span> to <span class="math notranslate nohighlight">\(v_{5}\)</span>. At this point <span class="math notranslate nohighlight">\(\mathcal{R}=\{(v_{4},S,3),(v_{4},S,2),(v_{5},S,2)\}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{Q}=\{(v_{7},2),(v_{8},2)\}\)</span>. Removing <span class="math notranslate nohighlight">\((v_{4},S,3)\)</span> from <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>, the Reducer traces back a path to <span class="math notranslate nohighlight">\(v_{0}\)</span> and creates the new node <span class="math notranslate nohighlight">\(v_{9}\)</span> labelled <span class="math notranslate nohighlight">\(1\)</span>, with an edge between <span class="math notranslate nohighlight">\(v_{9}\)</span> and <span class="math notranslate nohighlight">\(v_{0}\)</span>. As <span class="math notranslate nohighlight">\(\mathcal{T}(1,b)\)</span> contains the shift <span class="math notranslate nohighlight">\(p2\)</span>, <span class="math notranslate nohighlight">\((v_{9},2)\)</span> is also added to the set <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span>. When <span class="math notranslate nohighlight">\((v_{4},S,2)\)</span> is processed the Reducer traces back a path to <span class="math notranslate nohighlight">\(v_{2}\)</span> and creates a new edge between <span class="math notranslate nohighlight">\(v_{8}\)</span> and <span class="math notranslate nohighlight">\(v_{2}\)</span>. As a result of the new edge, <span class="math notranslate nohighlight">\((v_{2},S,2)\)</span> is added to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>.
When <span class="math notranslate nohighlight">\((v_{5},S,2)\)</span> and then <span class="math notranslate nohighlight">\((v_{2},S,2)\)</span> are processed, the Reducer traces back a path to <span class="math notranslate nohighlight">\(v_{0}\)</span> once again, but since the node labelled <span class="math notranslate nohighlight">\(1\)</span> already exists in the current level and there is an edge to <span class="math notranslate nohighlight">\(v_{0}\)</span>, nothing is done.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080525516.png" /></p>
<p>After processing the shift actions queued in <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span> the node labelled <span class="math notranslate nohighlight">\(2\)</span> is created in level <span class="math notranslate nohighlight">\(4\)</span>, with edges going back to the nodes labelled <span class="math notranslate nohighlight">\(4\)</span>, <span class="math notranslate nohighlight">\(3\)</span> and <span class="math notranslate nohighlight">\(1\)</span> in the previous level.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080526174.png" /></p>
<p>Notice that the node labelled <span class="math notranslate nohighlight">\(4\)</span> in the final level of the GSS in Figure 6.2 has edges that go back to every node labelled <span class="math notranslate nohighlight">\(4\)</span> in the previous levels. This pattern is repeated when recognising any strings of the form <span class="math notranslate nohighlight">\(b^{n}\)</span>. At each level <span class="math notranslate nohighlight">\(i\geq 3\)</span> in the GSS there is a node labelled <span class="math notranslate nohighlight">\(4\)</span> which has edges back to the nodes labelled <span class="math notranslate nohighlight">\(3\)</span> in each of the levels below <span class="math notranslate nohighlight">\(i\)</span> in the GSS. It is this property that is used in [10] to prove that the RNGLR algorithm takes at least <span class="math notranslate nohighlight">\(O(n^{4})\)</span> time when used to parse sentences <span class="math notranslate nohighlight">\(b^{n}\)</span> using the RN parse table for Grammar 6.1. Since Tomita’s Algorithm 1e builds the same GSS as the RNGLR algorithm, they share the property that triggers this worst case behaviour.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080526292.png" /></p>
<p>In fact the RNGLR algorithm is at most <span class="math notranslate nohighlight">\(O(n^{M+1})\)</span>, where <span class="math notranslate nohighlight">\(M\)</span> is the longest rule in the underlying grammar for any RN parse table when <span class="math notranslate nohighlight">\(M\geq 3\)</span>. Furthermore, grammars in the form of Grammar 6.2 trigger <span class="math notranslate nohighlight">\(O(n^{M})\)</span> behaviour in such GLR parsers.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080559956.png" /></p>
</section>
</section>
<section id="achieving-cubic-time-complexity-by-factoring-the-grammar">
<h2>6.2 Achieving cubic time complexity by factoring the grammar<a class="headerlink" href="#achieving-cubic-time-complexity-by-factoring-the-grammar" title="Permalink to this heading">¶</a></h2>
<p>The previous section discussed the properties of grammars that cause GLR recognisers to display polynomial behaviour. Since it is the searching that is done to find the target nodes of a reduction that determines the complexity of such algorithms, an obvious approach to reduce the complexity is to first reduce the searching. The length of the searches done for a reduction is directly related to the length of the grammar’s rules. Clearly, by restricting the length of the grammar’s rules, an improvement should be possible.</p>
<p>There are several existing algorithms that can transform any context-free grammar into another grammar whose rules have a maximum length of two [10]. One of the best known techniques, used by other parsing algorithms such as CYK, is to transform the grammar into Chomsky Normal Form (CNF). Although the algorithm that transforms a grammar to CNF produces a grammar with the desired property, it has two major drawbacks; the resulting parses are done with respect to the CNF grammar and the process to recover the derivations with respect to the original grammar can be expensive, and there is a linear increase in the size of the grammar [10].</p>
<p>Of course, it is not necessary to have CNF to have <span class="math notranslate nohighlight">\(O(n^{3})\)</span> complexity. All that is required is that the grammar rules all have length at most two. We can achieve this with a grammar which is close to the original by simply factoring the rules. In this way the generated derivations can be closely related to the original grammar.</p>
<p>Grammar 6.4 is the result of factoring Grammar 6.3 so that no right hand side has a length greater than two. Using factored grammars the RNGLR algorithm can parse in at most cubic time.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080527273.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080527047.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080527714.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080527012.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080528068.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080528132.png" />
We have to be careful when introducing extra non-terminals. If we only use one non-terminal for the two alternates of <span class="math notranslate nohighlight">\(S\)</span> in the following grammar the strings <span class="math notranslate nohighlight">\(aba\)</span> and <span class="math notranslate nohighlight">\(cbc\)</span> are incorrectly introduced to the language.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080529339.png" />
Thus new non-terminals need to be introduced for each reduction of each rule. Unfortunately this approach can also lead to a substantial increase in the size of the parse table. For example the <span class="math notranslate nohighlight">\(\operatorname{SLR}(1)\)</span> parse table for our IBM-VS Cobol grammar is <span class="math notranslate nohighlight">\(2.8\times 10^{6}\)</span> cells compared with <span class="math notranslate nohighlight">\(6.2\times 10^{6}\)</span> for the binarised grammar. The increase is even more dramatic for some <span class="math notranslate nohighlight">\(\operatorname{LR}(1)\)</span> tables. Our ANSI-C grammar has cells compared to the <span class="math notranslate nohighlight">\(8.0\times 10^{5}\)</span> cells of the factorised grammar. For a more detailed discussion of parse tables sizes see Chapter 10.</p>
</section>
<section id="achieving-cubic-time-complexity-by-modifying-the-parse-table">
<h2>6.3 Achieving cubic time complexity by modifying the parse table<a class="headerlink" href="#achieving-cubic-time-complexity-by-modifying-the-parse-table" title="Permalink to this heading">¶</a></h2>
<p>In the previous section we showed how to use the RNGLR algorithm to achieve cubic worst case complexity by factoring the grammar before parsing. Unfortunately, this technique can dramatically increase the size of the parse table. The objective of factoring the grammar was to restrict the length of the reductions performed during parsing. In this section we present a different approach which achieves the same complexity, but does not increase the size of the parse table to the same degree.</p>
<p>Instead of factoring the grammar it is possible to restrict the length of reductions performed by directly modifying the parse table. This involves the creation of <span class="math notranslate nohighlight">\(N_{A}\)</span> additional states for each non-terminal <span class="math notranslate nohighlight">\(A\)</span>, where <span class="math notranslate nohighlight">\((N_{A}+2)\)</span> is the longest alternate of <span class="math notranslate nohighlight">\(A\)</span>. So if <span class="math notranslate nohighlight">\(N_{A}\geq 1\)</span> then the additional states <span class="math notranslate nohighlight">\(A_{1}\ldots A_{N_{A}}\)</span> are created.</p>
<p>In addition to this, a new type of reduction action is added to the parse table so that only reductions with a maximum length of two are performed. The new reductions are of the form <span class="math notranslate nohighlight">\(r(A_{j},2)\)</span>, where <span class="math notranslate nohighlight">\(A_{j}\)</span> is an additional state and <span class="math notranslate nohighlight">\(2\)</span> is the length of the reduction. When such an action is performed two symbols are popped off the stack and <span class="math notranslate nohighlight">\(A_{j}\)</span> is pushed onto the stack. For example consider Grammar 6.3 and the associated BRN parse table 6.4. By using the parse table shown in Table 6.4 to parse the string <span class="math notranslate nohighlight">\(abcd\)</span>, the GSS in Figure 6.5 is constructed.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080529908.png" /></p>
<p>Although the GSS created with the use of the BRN parse table is larger than the one created with the RN table, the increase in size is only a constant factor. Both
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080530488.png" />
GSS’s have <span class="math notranslate nohighlight">\(O(n^{2})\)</span> edges, but the GSS generated by the BRN table can be constructed in at most cubic time.
In [SJE03] a proof is given that shows the BRN parse table accepts exactly the same set of strings as the RN parse table. Since there is another proof in [10] that shows the RN parse table to accept precisely the same strings as an LR(1) parser for the same grammar we can be rely on the parse table being correct.</p>
</section>
<section id="the-brnglr-recognition-algorithm">
<h2>6.4 The BRNGLR recognition algorithm<a class="headerlink" href="#the-brnglr-recognition-algorithm" title="Permalink to this heading">¶</a></h2>
<p>This section presents the formal definition of the BRNGLR recognition algorithm that uses BRN parse tables to parse sentences in at most cubic time.</p>
<section id="brnglr-recogniser">
<h3>BRNGLR recogniser<a class="headerlink" href="#brnglr-recogniser" title="Permalink to this heading">¶</a></h3>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080532344.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080532058.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080532930.png" /></p>
<p>Although the above algorithm succeeds in parsing all context-free grammars in at most cubic time, it is disappointing that the parse table increases in size (eventhough the increase is only by a constant factor). It turns out that because of the regular way the additional reductions are done, it is possible to achieve the same complexity without modifying the parse table. The following section describes such an algorithm.</p>
</section>
</section>
<section id="performing-on-the-fly-reduction-path-factorisation">
<h2>6.5 Performing ‘on-the-fly’ reduction path factorisation<a class="headerlink" href="#performing-on-the-fly-reduction-path-factorisation" title="Permalink to this heading">¶</a></h2>
<p>The algorithm defined in the previous section is an extension of the RNGLR algorithm which uses BRN parse tables to achieve cubic worst case time complexity. A further extension of the previous algorithm performs this binary translation ‘on-the-fly’. This algorithm works on an original RN parse table, but includes the extra machinery necessary to only carry out searches with a maximum length of two. When an action <span class="math notranslate nohighlight">\(r(X,m)\)</span> is encountered in the parse table, the algorithm stores the pending reduction in the set <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> in the form <span class="math notranslate nohighlight">\((v,X,m)\)</span>, where <span class="math notranslate nohighlight">\(v\)</span> is the target of the edge down which the reduction is to be applied and <span class="math notranslate nohighlight">\(m\)</span> is the length of the reduction. When <span class="math notranslate nohighlight">\(m&gt;2\)</span> a new edge is added from a special <em>bookkeeping</em> node labelled <span class="math notranslate nohighlight">\(X_{m}\)</span> in the current level to every child node <span class="math notranslate nohighlight">\(u\)</span> of <span class="math notranslate nohighlight">\(v\)</span> and the element <span class="math notranslate nohighlight">\((u,X,m-1)\)</span> is added to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>. This technique ensures that reductions of length greater than 2 are done in <span class="math notranslate nohighlight">\(m-1\)</span> steps of length two. The bookkeeping nodes prevent the repeated traversal of a path in the same way that the extra states added to the modified RN parse table do.</p>
<p>The on-the-fly algorithm is the preferred implementation of the BRNGLR algorithm as it does not increase the size of the RN parse table to achieve cubic worst case time complexity.</p>
<section id="brnglr-on-the-fly-recogniser">
<h3><strong>BRNGLR ‘on-the-fly’ recogniser</strong><a class="headerlink" href="#brnglr-on-the-fly-recogniser" title="Permalink to this heading">¶</a></h3>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080533558.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080534011.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080535479.png" /></p>
<p>For the formal proofs on the correctness and the complexity of the BRNGLR algorithm see [SJE03].</p>
<section id="example-on-the-fly-recognition-in-o-n-3-time">
<h4>Example - ‘on-the-fly’ recognition in <span class="math notranslate nohighlight">\(O(n^{3})\)</span> time<a class="headerlink" href="#example-on-the-fly-recognition-in-o-n-3-time" title="Permalink to this heading">¶</a></h4>
<p>To demonstrate the operation of the ‘on-the-fly’ BRNGLR recognition algorithm we shall trace the construction of the GSS for Grammar 6.5 and the input <span class="math notranslate nohighlight">\(abcd\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310102310699.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080535569.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080536057.png" />
As usual we begin by first creating the node <span class="math notranslate nohighlight">\(v_{0}\)</span> labelled with the start state of the DFA in Figure 6.6 and then proceed to add the actions found in <span class="math notranslate nohighlight">\(\mathcal{T}(0,a)\)</span> to the appropriate sets. In this case, only the shift action <span class="math notranslate nohighlight">\(p2\)</span> is added to the set <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span>, which results in the node <span class="math notranslate nohighlight">\(v_{1}\)</span> labelled <span class="math notranslate nohighlight">\(2\)</span> and the edge from <span class="math notranslate nohighlight">\(v_{1}\)</span> to <span class="math notranslate nohighlight">\(v_{0}\)</span> being created. Continuing in this way, the next three states created for the remainder of the input string result in the partial GSS shown below.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080536570.png" /></p>
<p>At this point we have <span class="math notranslate nohighlight">\(\mathcal{R}=\{(v_{3},S,4),(v_{3},D,1)\}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{Q}=\{\}\)</span>. When we process <span class="math notranslate nohighlight">\((v_{3},S,4)\)</span> we find <span class="math notranslate nohighlight">\(v_{2}\)</span>, the only child of <span class="math notranslate nohighlight">\(v_{3}\)</span>, and add it to the set <span class="math notranslate nohighlight">\(\chi\)</span>. Since there is no bookkeeping node labelled <span class="math notranslate nohighlight">\(S_{4}\)</span> in the current level of the GSS we create one, <span class="math notranslate nohighlight">\(v_{5}\)</span>, add an edge between <span class="math notranslate nohighlight">\(v_{5}\)</span> and <span class="math notranslate nohighlight">\(v_{3}\)</span> and then add the additional reduction <span class="math notranslate nohighlight">\((v_{2},S,3)\)</span> to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080536429.png" /></p>
<p>We then process <span class="math notranslate nohighlight">\((v_{3},D,1)\)</span>. Since the reduction length is less than <span class="math notranslate nohighlight">\(2\)</span>, we perform a normal reduction which results in the creation of a new node, <span class="math notranslate nohighlight">\(v_{6}\)</span>, labelled <span class="math notranslate nohighlight">\(6\)</span>, with an edge back to <span class="math notranslate nohighlight">\(v_{3}\)</span>. There is a reduction <span class="math notranslate nohighlight">\(r(S,4)\in\mathcal{T}(6,\$)\)</span> so we add <span class="math notranslate nohighlight">\((v_{3},S,4)\)</span> into <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080536946.png" /></p>
<p>Processing <span class="math notranslate nohighlight">\((v_{2},S,3)\)</span>, we find <span class="math notranslate nohighlight">\(v_{1}\)</span>, the only child of <span class="math notranslate nohighlight">\(v_{2}\)</span>, and add it to <span class="math notranslate nohighlight">\(\chi\)</span>. Since there is no node labelled <span class="math notranslate nohighlight">\(S_{3}\)</span> in the current level, we create <span class="math notranslate nohighlight">\(v_{7}\)</span> and add an edge between <span class="math notranslate nohighlight">\(v_{7}\)</span> and the only node in <span class="math notranslate nohighlight">\(\chi\)</span>, <span class="math notranslate nohighlight">\(v_{1}\)</span>. The final additional reduction, <span class="math notranslate nohighlight">\((v_{1},S,2)\)</span>, is added to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080537394.png" /></p>
<p>When we process the reduction for <span class="math notranslate nohighlight">\((v_{3},S,4)\)</span> we check to see if a bookkeeping node labelled <span class="math notranslate nohighlight">\(S_{4}\)</span> already exists in the current level. It does. Because we already performed a reduction of length <span class="math notranslate nohighlight">\(4\)</span> for a rule defined by the non-terminal <span class="math notranslate nohighlight">\(S\)</span>, whose path included <span class="math notranslate nohighlight">\(v_{3}\)</span>, we do not need to continue with the current reduction. Clearly this reduces the amount of edge visits that we perform during the parse.</p>
<p>We continue by performing the reduction for <span class="math notranslate nohighlight">\((v_{1},S,2)\)</span>. We find <span class="math notranslate nohighlight">\(v_{0}\)</span>, the only child of <span class="math notranslate nohighlight">\(v_{1}\)</span> and create the new node <span class="math notranslate nohighlight">\(v_{8}\)</span> labelled <span class="math notranslate nohighlight">\(1\)</span>, with an edge labelled <span class="math notranslate nohighlight">\(S\)</span> to <span class="math notranslate nohighlight">\(v_{0}\)</span>. Since we have consumed all the input and <span class="math notranslate nohighlight">\(v_{8}\)</span> is labelled by the accept state of the DFA the input <span class="math notranslate nohighlight">\(abcd\)</span> is successfully accepted. The final GSS is shown below.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080537142.png" /></p>
</section>
</section>
</section>
<section id="glr-parsing-in-at-most-cubic-time">
<h2>6.6 GLR parsing in at most cubic time<a class="headerlink" href="#glr-parsing-in-at-most-cubic-time" title="Permalink to this heading">¶</a></h2>
<p>We extend the BRNGLR recognition algorithm to a parser by constructing an SPPF in a similar way to the approach we take for the RNGLR algorithm (see Chapter 5). Recall that nodes can be packed if their yields correspond to the same portion of the input string. In order to ensure that a correct SPPF is constructed care needs to be taken when dealing with the bookkeeping SPPF nodes. (Note that the bookkeeping SPPF nodes are not labelled.) We give the algorithm and then illustrate the basic issues using Grammar 6.3. We then discuss the subtleties of the use of bookkeeping nodes in Section 6.7.</p>
<section id="brnglr-parser">
<h3>BRNGLR parser<a class="headerlink" href="#brnglr-parser" title="Permalink to this heading">¶</a></h3>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080539121.png" />
<img alt="Layer 3.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080549116.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080550484.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080551109.png" /></p>
</section>
<section id="example-parsing-in-o-n-3-time">
<h3>Example - parsing in <span class="math notranslate nohighlight">\(O(n^{3})\)</span> time<a class="headerlink" href="#example-parsing-in-o-n-3-time" title="Permalink to this heading">¶</a></h3>
<p>To illustrate the operation of the algorithm we shall trace the construction of the GSS and SPPF for the string <span class="math notranslate nohighlight">\(abcd\)</span> in the language of Grammar 6.3 shown on page 6.3.
We begin by constructing the GSS node <span class="math notranslate nohighlight">\(v_{0}\)</span> labelled by the start state of the DFA. Since <span class="math notranslate nohighlight">\(p2\in\mathcal{T}(0,a)\)</span> we create the node <span class="math notranslate nohighlight">\(v_{1}\)</span> labelled <span class="math notranslate nohighlight">\(2\)</span>, the SPPF node <span class="math notranslate nohighlight">\(w_{0}\)</span> labelled <span class="math notranslate nohighlight">\((a,0)\)</span> and the edge from <span class="math notranslate nohighlight">\(v_{1}\)</span> to <span class="math notranslate nohighlight">\(v_{0}\)</span> in the GSS which is labelled by <span class="math notranslate nohighlight">\(w_{0}\)</span>.</p>
<p>We proceed to shift the next three input symbols in the same way, which results in the GSS and SPPF shown in Figure 6.7 being constructed.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080551197.png" /></p>
<p>At this point <span class="math notranslate nohighlight">\(\mathcal{R}=\{(v_{3},B,1,0,w_{3}),(v_{3},D,1,0,w_{3})\}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{Q}=\{\}\)</span>. Processing <span class="math notranslate nohighlight">\((v_{3},B,1,0,w_{3})\)</span> results in the creation of node <span class="math notranslate nohighlight">\(v_{5}\)</span> labelled <span class="math notranslate nohighlight">\(6\)</span>, the SPPF node <span class="math notranslate nohighlight">\(w_{4}\)</span> and the edge between <span class="math notranslate nohighlight">\(v_{5}\)</span> and <span class="math notranslate nohighlight">\(v_{3}\)</span> labelled by <span class="math notranslate nohighlight">\(w_{4}\)</span>. The action in <span class="math notranslate nohighlight">\(\mathcal{T}(6,\$)\)</span> is the reduction <span class="math notranslate nohighlight">\(r(S,4)\)</span> so <span class="math notranslate nohighlight">\((v_{3},S,4,0,w_{4})\)</span> is added to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>. We then remove <span class="math notranslate nohighlight">\((v_{3},D,1,0,w_{3})\)</span> from <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> and process the reduction, which results in the GSS and SPPF shown in Figure 6.8 being constructed and <span class="math notranslate nohighlight">\((v_{3},S,4,0,w_{5})\)</span> added to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080552627.png" /></p>
<p>Since the next element, <span class="math notranslate nohighlight">\((v_{3},S,4,0,w_{4})\)</span>, that we process from <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> has a reduction length greater than two, we collect the children and edges of the reduction’s source node, <span class="math notranslate nohighlight">\(v_{3}\)</span>, in the set <span class="math notranslate nohighlight">\(\chi=\{(v_{2},w_{2})\}\)</span>. We then create a new bookkeeping node <span class="math notranslate nohighlight">\(v_{8}\)</span> labelled <span class="math notranslate nohighlight">\(S_{4}\)</span> and the SPPF node <span class="math notranslate nohighlight">\(w_{6}\)</span> which labels the new edge from <span class="math notranslate nohighlight">\(v_{8}\)</span> to <span class="math notranslate nohighlight">\(v_{2}\)</span>. In order to ensure that the correct number of reduction steps are done we also add the binary reduction <span class="math notranslate nohighlight">\((v_{2},S,3,0,w_{6})\)</span> to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>. The only operation that remains to be done is to add the SPPF nodes collected in <span class="math notranslate nohighlight">\(\chi\)</span> and the single node <span class="math notranslate nohighlight">\(y\)</span>, which is passed into the Reducer, as children of the new bookkeeping SPPF node <span class="math notranslate nohighlight">\(w_{6}\)</span>. We do this by calling the AddChildren function with the parameters <span class="math notranslate nohighlight">\((w_{6},(w_{2},w_{4}),0)\)</span>. Since <span class="math notranslate nohighlight">\(w_{6}\)</span> does not have any existing children, edges to <span class="math notranslate nohighlight">\(w_{2}\)</span> and <span class="math notranslate nohighlight">\(w_{4}\)</span> are created. The GSS and SPPF constructed up to this point are shown in Figure 6.9.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080552184.png" /></p>
<p>When we remove and process the reduction <span class="math notranslate nohighlight">\((v_{3},S,4,0,w_{5})\)</span> from <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> we proceed in the same way as before by collecting the children and edges of the reduction’s source node in the set <span class="math notranslate nohighlight">\(\chi=\{(v_{2},w_{2})\}\)</span>. However, since there already exists a node in the current level that is labelled <span class="math notranslate nohighlight">\(S_{4}\)</span> we do not create a new one and since there is already an edge from <span class="math notranslate nohighlight">\(v_{8}\)</span> to <span class="math notranslate nohighlight">\(v_{2}\)</span> no edge is created either. Instead we make sure that the existing SPPF node <span class="math notranslate nohighlight">\(w_{6}\)</span> has the correct children by calling AddChildren with the parameters <span class="math notranslate nohighlight">\((w_{6},(w_{5},w_{2}),0)\)</span>.</p>
<p>Since <span class="math notranslate nohighlight">\(w_{6}\)</span> has a sequence of children that is not labelled <span class="math notranslate nohighlight">\((w_{5},w_{2})\)</span> we create two new packing nodes as children of <span class="math notranslate nohighlight">\(w_{6}\)</span> and add the two sequences of SPPF nodes to them as children. This results in the SPPF shown in Figure 6.10 being constructed.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080552823.png" /></p>
<p>At this point <span class="math notranslate nohighlight">\(\mathcal{R}=\{(v_{2},S,1,0,w_{6})\}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{Q}=\{\}\)</span>. Processing <span class="math notranslate nohighlight">\((v_{2},S,3,0,w_{6})\)</span> we add <span class="math notranslate nohighlight">\(\{(v_{1},w_{1})\}\)</span> to <span class="math notranslate nohighlight">\(\chi\)</span> and since <span class="math notranslate nohighlight">\(m\)</span> is greater than 2, we proceed to create a new node <span class="math notranslate nohighlight">\(v_{9}\)</span> labelled <span class="math notranslate nohighlight">\(S_{3}\)</span>, a new SPPF node <span class="math notranslate nohighlight">\(w_{7}\)</span> and an edge from <span class="math notranslate nohighlight">\(v_{9}\)</span> to <span class="math notranslate nohighlight">\(v_{1}\)</span> which is labelled by <span class="math notranslate nohighlight">\(w_{7}\)</span>. We then add <span class="math notranslate nohighlight">\((v_{1},S,2,0,w_{7})\)</span> for the final reduction step of the binary sequence of reductions to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>. Finally, we call AddChildren<span class="math notranslate nohighlight">\((w_{7},(w_{6},w_{1}),0)\)</span> which adds <span class="math notranslate nohighlight">\(w_{6}\)</span> and <span class="math notranslate nohighlight">\(w_{1}\)</span> as children of <span class="math notranslate nohighlight">\(w_{7}\)</span> and results in the SPPF shown in Figure 6.11 being constructed.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080553066.png" /></p>
<p>When we process <span class="math notranslate nohighlight">\((v_{1},S,2,0,w_{7})\)</span> we trace back to node <span class="math notranslate nohighlight">\(v_{0}\)</span> and add <span class="math notranslate nohighlight">\((v_{0},w_{0})\)</span> to <span class="math notranslate nohighlight">\(\chi\)</span>. Since <span class="math notranslate nohighlight">\(m=2\)</span> we recognise that this reduction will be completed in this step, so we find the goto action <span class="math notranslate nohighlight">\(p_{1}\)</span> in <span class="math notranslate nohighlight">\(\mathcal{T}(0,S)\)</span>. We then create the new node <span class="math notranslate nohighlight">\(v_{10}\)</span> labelled <span class="math notranslate nohighlight">\(1\)</span> and the SPPF node <span class="math notranslate nohighlight">\(w_{8}\)</span> labelled <span class="math notranslate nohighlight">\((S,0)\)</span>, which we use to label the edge between nodes <span class="math notranslate nohighlight">\(v_{10}\)</span> and <span class="math notranslate nohighlight">\(v_{0}\)</span>. The subsequent call to AddChildren with the parameters <span class="math notranslate nohighlight">\((w_{8},(w_{0},w_{7}),0)\)</span> results in the final SPPF shown in Figure 6.12 being constructed.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080553841.png" /></p>
</section>
</section>
<section id="packing-of-bookkeeping-sppf-nodes">
<h2>6.7 Packing of bookkeeping SPPF nodes<a class="headerlink" href="#packing-of-bookkeeping-sppf-nodes" title="Permalink to this heading">¶</a></h2>
<p>The previous section demonstrated how the ‘on-the-fly’ BRNGLR parsing algorithm builds an SPPF during parsing. At first it may appear that in general we could pack some of the bookkeeping nodes in the SPPF more effectively. In fact we cannot do this because incorrect derivations may be introduced to the SPPF. This section highlights the subtlety of packing bookkeeping nodes by tracing the construction of a GSS and SPPF for a grammar and string that will introduce incorrect derivations if the packing is done naively.</p>
<section id="example-how-to-pack-bookkeeping-sppf-nodes">
<h3>Example - how to pack bookkeeping SPPF nodes<a class="headerlink" href="#example-how-to-pack-bookkeeping-sppf-nodes" title="Permalink to this heading">¶</a></h3>
<p>It is only possible to pack two bookkeeping SPPF nodes when they arise from different reductions whose target is the same state node. Consider Grammar 6.6, the LR(1) DFA in Figure 6.13 and RN parse table in Table 6.6. We can illustrate the consequences of incorrectly packing the bookkeeping SPPF nodes when parsing the string <span class="math notranslate nohighlight">\(abc\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080554807.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080554622.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080555198.png" /></p>
<p>We begin in the usual way, creating the node <span class="math notranslate nohighlight">\(v_{0}\)</span> labelled with the start state of the DFA and adding the actions from the associated parse table entry to the sets <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span>. Since <span class="math notranslate nohighlight">\(p2\)</span> is the only action in <span class="math notranslate nohighlight">\(\mathcal{T}(0,a)\)</span> we shift the first input symbol and create a new node <span class="math notranslate nohighlight">\(v_{1}\)</span> labelled <span class="math notranslate nohighlight">\(2\)</span>, an SPPF node <span class="math notranslate nohighlight">\(w_{0}\)</span> labelled <span class="math notranslate nohighlight">\((a,0)\)</span> and an edge from <span class="math notranslate nohighlight">\(v_{1}\)</span> to <span class="math notranslate nohighlight">\(v_{0}\)</span> labelled by <span class="math notranslate nohighlight">\(w_{0}\)</span>. There is a shift/reduce conflict in the parse table at <span class="math notranslate nohighlight">\(\mathcal{T}(2,b)\)</span> so <span class="math notranslate nohighlight">\((v_{1},4)\)</span> and <span class="math notranslate nohighlight">\((v_{0},A,1,0,w_{0})\)</span> are added to the sets <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> respectively. Processing <span class="math notranslate nohighlight">\((v_{0},A,1,0,w_{0})\)</span> results in the node <span class="math notranslate nohighlight">\(v_{1}\)</span> labelled <span class="math notranslate nohighlight">\(3\)</span>, the SPPF node <span class="math notranslate nohighlight">\(w_{1}\)</span> labelled <span class="math notranslate nohighlight">\((A,0)\)</span> and the edge from <span class="math notranslate nohighlight">\(v_{1}\)</span> to <span class="math notranslate nohighlight">\(v_{0}\)</span> labelled by <span class="math notranslate nohighlight">\(w_{1}\)</span> being created. Since the shift action <span class="math notranslate nohighlight">\(p5\)</span> is in <span class="math notranslate nohighlight">\(\mathcal{T}(3,b)\)</span>, <span class="math notranslate nohighlight">\((v_{2},5)\)</span> is added to the set <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span>. We then call the AddChildren function with the parameters <span class="math notranslate nohighlight">\((v_{1},(w_{0}),0)\)</span>, which results in the SPPF node <span class="math notranslate nohighlight">\(w_{0}\)</span> being added to <span class="math notranslate nohighlight">\(w_{1}\)</span> as a child.</p>
<p>At this point, no other reductions are queued in the set <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> so the shifts are processed from the set <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span> by the Shifter. This results in the new nodes <span class="math notranslate nohighlight">\(v_{3}\)</span> and <span class="math notranslate nohighlight">\(v_{4}\)</span> being created, with edges to <span class="math notranslate nohighlight">\(v_{1}\)</span> and <span class="math notranslate nohighlight">\(v_{2}\)</span> labelled by the newly created SPPF node <span class="math notranslate nohighlight">\(w_{2}\)</span>. Both nodes <span class="math notranslate nohighlight">\(v_{3}\)</span> and <span class="math notranslate nohighlight">\(v_{4}\)</span> only have shift actions in their respective parse table entries so the new nodes <span class="math notranslate nohighlight">\(v_{5}\)</span> and <span class="math notranslate nohighlight">\(v_{6}\)</span> are created along with the associated SPPF node <span class="math notranslate nohighlight">\(w_{3}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080556885.png" /></p>
<p>At this point <span class="math notranslate nohighlight">\(\mathcal{R}=\{(v_{3},B,1,0,w_{3}),(v_{3},D,1,0,w_{3}),(v_{4},B,1,0,w_{3})\}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{Q}=\{\}\)</span>. Processing the first element in <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> results in the new node <span class="math notranslate nohighlight">\(v_{7}\)</span> labelled <span class="math notranslate nohighlight">\(6\)</span>, the SPPF node <span class="math notranslate nohighlight">\(w_{4}\)</span> labelled <span class="math notranslate nohighlight">\((B,2)\)</span> and the edge from <span class="math notranslate nohighlight">\(v_{7}\)</span> to <span class="math notranslate nohighlight">\(v_{3}\)</span> being created. Since the length of the reduction is one, we find the new reduction <span class="math notranslate nohighlight">\(r(S,3,0)\)</span> in <span class="math notranslate nohighlight">\(\mathcal{T}(6,\$)\)</span> and add <span class="math notranslate nohighlight">\((v_{3},S,3,0,w_{4})\)</span> to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> before proceeding to call AddChildren<span class="math notranslate nohighlight">\((w_{4},(w_{3}),0)\)</span> which makes <span class="math notranslate nohighlight">\(w_{3}\)</span> a child of <span class="math notranslate nohighlight">\(w_{4}\)</span> in the SPPF.</p>
<p>When we remove <span class="math notranslate nohighlight">\((v_{3},D,1,0,w_{3})\)</span> from <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> and continue to process the reduction in the Reducer, we create the new node <span class="math notranslate nohighlight">\(v_{8}\)</span> labelled <span class="math notranslate nohighlight">\(7\)</span>, the SPPF node <span class="math notranslate nohighlight">\(w_{5}\)</span> labelled <span class="math notranslate nohighlight">\((D,2)\)</span> and the edge between <span class="math notranslate nohighlight">\(v_{8}\)</span> and <span class="math notranslate nohighlight">\(v_{3}\)</span> labelled by <span class="math notranslate nohighlight">\(w_{5}\)</span>. The new reduction <span class="math notranslate nohighlight">\((v_{3},S,3,0,w_{5})\)</span> is added to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> and then AddChildren<span class="math notranslate nohighlight">\((w_{5},(w_{3}),0)\)</span> is called which results in <span class="math notranslate nohighlight">\(w3\)</span> being made a child of <span class="math notranslate nohighlight">\(w_{5}\)</span>.</p>
<p>Then we remove <span class="math notranslate nohighlight">\((v_{4},B,1,0,w_{3})\)</span> from <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> which results in the node <span class="math notranslate nohighlight">\(v_{9}\)</span> labelled <span class="math notranslate nohighlight">\(9\)</span> being created in the GSS. Since an edge does not already exist from <span class="math notranslate nohighlight">\(v_{9}\)</span> to <span class="math notranslate nohighlight">\(v_{4}\)</span> one is created. However, because we have already created an SPPF node labelled <span class="math notranslate nohighlight">\((B,2)\)</span> while constructing the current level, which we find in the set <span class="math notranslate nohighlight">\(\mathcal{N}\)</span>, we reuse it to label the new edge. In addition to this because the parse table contains the reduction <span class="math notranslate nohighlight">\(r(S,3,0)\)</span> in <span class="math notranslate nohighlight">\(\mathcal{T}(9,\$)\)</span>, we add <span class="math notranslate nohighlight">\((v_{4},S,3,0,w_{5})\)</span> to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080556254.png" /></p>
<p>We then continue processing the remaining reductions <span class="math notranslate nohighlight">\((v_{3},S,3,0,w_{4})\)</span>, <span class="math notranslate nohighlight">\((v_{3},S,3,0,w_{5})\)</span> and <span class="math notranslate nohighlight">\((v_{4},S,3,0,w_{5})\)</span> from the set <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>. For <span class="math notranslate nohighlight">\((v_{3},S,3,0,w_{4})\)</span> the Reducer determines that the length of the reduction is greater than two and proceeds to perform a binary reduction. The child node and edge <span class="math notranslate nohighlight">\((v_{1},w_{2})\)</span>, from node <span class="math notranslate nohighlight">\(v_{3}\)</span> are found and added to the set <span class="math notranslate nohighlight">\(\chi\)</span>. A new bookkeeping node <span class="math notranslate nohighlight">\(v_{10}\)</span> labelled <span class="math notranslate nohighlight">\(S_{3}\)</span> is then created and an edge is added between <span class="math notranslate nohighlight">\(v_{10}\)</span> and <span class="math notranslate nohighlight">\(v_{1}\)</span>. The final binary reduction of the sequence <span class="math notranslate nohighlight">\((v_{1},S,2,0,w_{6})\)</span> is also added to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> before the SPPF is updated by AddChildren<span class="math notranslate nohighlight">\((w_{6},(w_{2},w_{4}),0)\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080557834.png" /></p>
<p>When <span class="math notranslate nohighlight">\((v_{3},S,3,0,w_{5})\)</span> is processed, another binary reduction is performed by the Reducer. Once again the child node and edge <span class="math notranslate nohighlight">\((v_{1},w_{2})\)</span>, from node <span class="math notranslate nohighlight">\(v_{3}\)</span> are found and added to the set <span class="math notranslate nohighlight">\(\chi\)</span>. However, since there is already a node in the current level that is labelled <span class="math notranslate nohighlight">\(S_{3}\)</span>, we do not create a new one, but reuse the existing one. In addition to this, because there is already an edge between <span class="math notranslate nohighlight">\(v_{10}\)</span> and <span class="math notranslate nohighlight">\(v_{1}\)</span>, we also reuse the edge and SPPF node. When we finally call AddChildren<span class="math notranslate nohighlight">\((w_{6},(w_{2},w_{5}),0)\)</span>, we find that two new packing nodes need to be created as children of <span class="math notranslate nohighlight">\(w_{6}\)</span>. So we add the original sequence of children to one packing node and the new sequence that is passed into AddChildren to the other.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080557518.png" /></p>
<p>When we process <span class="math notranslate nohighlight">\((v_{4},S,3,0,w_{5})\)</span>, another binary reduction is performed. We begin by setting <span class="math notranslate nohighlight">\(\chi=\{(v_{2},w_{2})\}\)</span>. Since we already have a node labelled <span class="math notranslate nohighlight">\(S_{3}\)</span> in the current level of the GSS, we can use it again. However, because there is no edge that goes between <span class="math notranslate nohighlight">\(v_{10}\)</span> and <span class="math notranslate nohighlight">\(v_{2}\)</span>, we create a new one and label it with a new SPPF node <span class="math notranslate nohighlight">\(w_{7}\)</span>. Before calling the AddChildren function we add the remaining binary reduction <span class="math notranslate nohighlight">\((v_{2},S,2,0,w_{7})\)</span> to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080557081.png" /></p>
<p>Processing the final two reductions, <span class="math notranslate nohighlight">\((v_{1},S,2,0,w_{6})\)</span> and <span class="math notranslate nohighlight">\((v_{2},S,2,0,w_{7})\)</span>, held in <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> results in the node <span class="math notranslate nohighlight">\(v_{11}\)</span> being created in the GSS that is labelled with the accepting state of the DFA. Since <span class="math notranslate nohighlight">\(v_{11}\)</span> is in the final level of the GSS, the string <span class="math notranslate nohighlight">\(abc\)</span> is accepted by the parser. The final GSS and SPPF constructed by the BRNGLR parsing algorithm are shown in Figure 6.14.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080557181.png" /></p>
<p>At first, it may appear that it is possible to pack the two SPPF nodes <span class="math notranslate nohighlight">\(w_{6}\)</span> and <span class="math notranslate nohighlight">\(w_{7}\)</span> to produce the more compact SPPF shown in Figure 6.15. Unfortunately if this is done the following incorrect ‘derivation’ will be included.</p>
<div class="math notranslate nohighlight">
\[S^{\prime}\Rightarrow S\Rightarrow AbD\Rightarrow abD\Rightarrow abc\]</div>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080558677.png" /></p>
</section>
</section>
<section id="summary">
<h2>6.8 Summary<a class="headerlink" href="#summary" title="Permalink to this heading">¶</a></h2>
<p>In this chapter we have presented an algorithm capable of parsing all context-free grammars in at most <span class="math notranslate nohighlight">\(O(n^{3})\)</span> time and space. Two versions of the recognition algorithm were presented. The first worked on modified RN parse tables which included new states and reduction actions to ensure reductions of at most length two were done. The second algorithm used RN parse tables and split reductions with lengths <span class="math notranslate nohighlight">\(m&gt;2\)</span> into <span class="math notranslate nohighlight">\(m-1\)</span> reductions of length 2 ‘on-the-fly’. This did not require any modifications to be done to the parse table or the grammar, and hence did not increase the size of the parser.
The ‘on-the-fly’ recognition algorithm was then extended to a parser which is able to construct an SPPF representation of all possible derivations for a given input string in at most cubic time and space.
Proofs of the correctness of the algorithms and their complexity analysis can be found in [13]. Chapter 10 presents the experimental results for grammars which trigger worst case performance and several programming language grammars and strings. The results corroborate the complexity analysis and provide an encouraging comparison between BRNGLR and other general parsing algorithms.
The next chapter presents another general parsing algorithm that achieves cubic worst case time complexity by minimising the amount of stack activity that is done during parsing.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="5%20Right%20Nulled%20Generalised%20LR%20parsing.html" class="btn btn-neutral float-left" title="5. Right Nulled Generalised LR parsing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="7%20Reduction%20Incorporated%20Generalised%20LR%20parsing.html" class="btn btn-neutral float-right" title="7.Reduction Incorporated Generalised LR parsing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, xrtero.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>