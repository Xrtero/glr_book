<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>4. Generalised LR parsing &mdash; Generalised LR parsing algorithms  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="canonical" href="https://www.xrtero.com/book/glr/4 Generalised LR parsing.html" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=b3ba4146"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5. Right Nulled Generalised LR parsing" href="5%20Right%20Nulled%20Generalised%20LR%20parsing.html" />
    <link rel="prev" title="3. The development of generalised parsing" href="3%20The%20development%20of%20generalised%20parsing.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Generalised LR parsing algorithms
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1%20Introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="2%20%20Recognition%20and%20parsing.html">2. Recognition and parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="3%20The%20development%20of%20generalised%20parsing.html">3. The development of generalised parsing</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. Generalised LR parsing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#using-the-lr-algorithm-to-parse-all-context-free-grammars">4.1 Using the LR algorithm to parse all context-free grammars</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tomita-s-generalised-lr-parsing-algorithm">4.2  Tomita’s Generalised LR parsing algorithm</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#graph-structured-stacks">4.2.1 Graph structured stacks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-constructing-a-gss">4.2.2 Example - constructing a GSS</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tomita-s-algorithm-1">4.2.3 Tomita’s Algorithm 1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#parsing-with-epsilon-rules">4.2.4 Parsing with <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tomita-s-algorithm-2">4.2.5 Tomita’s Algorithm 2</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-non-termination-of-algorithm-2">The non-termination of Algorithm 2</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#farshi-s-extension-of-algorithm-1">4.3 Farshi’s extension of Algorithm 1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#farshi-s-recogniser">Farshi’s recogniser</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-a-hidden-left-recursive-grammar">4.3.1 Example - a hidden-left recursive grammar</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-a-hidden-right-recursive-grammar">4.3.2 Example - a hidden-right recursive grammar</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#constructing-derivations">4.4 Constructing derivations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#shared-packed-parse-forests">4.4.1 Shared packed parse forests</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tomita-s-algorithm-4">4.4.2 Tomita’s Algorithm 4</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rekers-sppf-construction">4.4.3 Rekers’ SPPF construction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rekers-parser-with-improved-sharing-in-the-sppf"><strong>Rekers’ parser with improved sharing in the SPPF</strong></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#summary">4.5 Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="5%20Right%20Nulled%20Generalised%20LR%20parsing.html">5. Right Nulled Generalised LR parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="6%20Binary%20Right%20Nulled%20Generalised%20LR%20parsing.html">6.Binary Right Nulled Generalised LR parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="7%20Reduction%20Incorporated%20Generalised%20LR%20parsing.html">7.Reduction Incorporated Generalised LR parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="8%20Other%20approaches%20to%20generalised%20parsing.html">8 Other approaches to generalised parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="9%20Some%20generalised%20parser%20generators.html">9. Some generalised parser generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="10%20Experimental%20investigation.html">10. Experimental investigation</a></li>
<li class="toctree-l1"><a class="reference internal" href="11%20Concluding%20remarks.html">11. Concluding remarks</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Generalised LR parsing algorithms</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">4. Generalised LR parsing</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/4 Generalised LR parsing.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="generalised-lr-parsing">
<h1>4. Generalised LR parsing<a class="headerlink" href="#generalised-lr-parsing" title="Permalink to this heading">¶</a></h1>
<p>As we have already discussed in earlier chapters, context-free grammars were developed by Noam Chomsky in the 1950’s in an attempt to capture the key properties of human languages. Computer scientists took advantage of their declarative structure and used them to define the syntax of programming languages. Many parsing algorithms capable of parsing all context-free grammars were developed, but their poor worst case performance often made then impractical. As a result more efficient parsing algorithms which worked on a subclass of the context-free grammars were developed.</p>
<p>The efficiency of the contemporary generalised parsing techniques (CYK, Earley, etc.) were disappointing when compared to Knuth’s deterministic LR parsing algorithm. Its popularity had soared, but the class of grammars it accepted was too restrictive for the practical applications that interested Tomita - natural language processing. In 1985, he developed the GLR parsing algorithm by extending the LR algorithm to work on non-LR grammars.</p>
<p>This chapter presents Tomita’s GLR recognition and parsing algorithms [Tom86, Tom91]. Although these algorithms work for a larger class of grammars than the LR parsers they cannot correctly parse all context-free grammars. We discuss the modification due to Farshi [NF91], that extends Tomita’s recognition algorithm to work for all context-free grammars and then discuss Rekers’ [Rek92] parser extension.</p>
<section id="using-the-lr-algorithm-to-parse-all-context-free-grammars">
<h2>4.1 Using the LR algorithm to parse all context-free grammars<a class="headerlink" href="#using-the-lr-algorithm-to-parse-all-context-free-grammars" title="Permalink to this heading">¶</a></h2>
<p>In Chapter 2 we described the standard LR parsing algorithm. LR parsers are extremely efficient, but are restricted by the class of grammars they accept. Although they work for a useful subset of the context-free grammars, they cannot cope with non-determinism.</p>
<p>A naive approach to dealing with non-determinism in an LR parser is to duplicatea stack when a conflict in the parse table is encountered. An approach presented in [12] uses a <em>stack list</em> to represent the different stacks of a non-deterministic parse. Each stack in the stack list is controlled by a separate LR parsing process that works in the same way as the standard LR algorithm. However, each process essentially works in parallel by synchronising on the shift actions.</p>
<p>Each stack in the stack list is represented by a graph, where the nodes are labelled with a state number and the edges are labelled with the symbol parsed. The right-most nodes are the tops of each stack. For example, consider the parse of the string <span class="math notranslate nohighlight">\(abd\)</span> for the ambiguous Grammar 4.1 and the DFA in Figure 4.1. The associated LR(1) parse table, with conflicts, is shown in Table 4.1.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080021892.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080021519.png" /></p>
<p>We begin the parse by creating the start node, <span class="math notranslate nohighlight">\(v_{0}\)</span>, of the stack list, labelled by the start state of the DFA. We read the first input symbol, <span class="math notranslate nohighlight">\(a\)</span>, and then perform the shift from state <span class="math notranslate nohighlight">\(0\)</span> to state <span class="math notranslate nohighlight">\(2\)</span>. We create a new node, <span class="math notranslate nohighlight">\(v_{1}\)</span> in the stack list, labelled <span class="math notranslate nohighlight">\(2\)</span>, and add an edge, labelled <span class="math notranslate nohighlight">\(a\)</span> back to <span class="math notranslate nohighlight">\(v_{0}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080021160.png" />
We then proceed to read the next input symbol, <span class="math notranslate nohighlight">\(b\)</span>, and create the node, <span class="math notranslate nohighlight">\(v_{2}\)</span>, labelled <span class="math notranslate nohighlight">\(3\)</span> with an edge back to <span class="math notranslate nohighlight">\(v_{1}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080021524.png" />
At this point we are in state <span class="math notranslate nohighlight">\(3\)</span> of the DFA which contains a shift/reduce conflict. Since we do not know which action to perform, we duplicate the stack and perform both actions.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080022593.png" />
We synchronise the stack list on shift actions, so we perform the reduce <span class="math notranslate nohighlight">\(B::=b\)</span> on the bottom stack first. This involves popping the node <span class="math notranslate nohighlight">\(v_{5}\)</span> off the stack and adding a new node <span class="math notranslate nohighlight">\(v_{6}\)</span>, labelled <span class="math notranslate nohighlight">\(4\)</span>, with an edge labelled <span class="math notranslate nohighlight">\(B\)</span> back to <span class="math notranslate nohighlight">\(v_{4}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080022928.png" /></p>
<p>We then read the next input symbol, <span class="math notranslate nohighlight">\(d\)</span>, and perform the synchronised shift action, <span class="math notranslate nohighlight">\(s6\)</span>, for both stacks. We create the new nodes <span class="math notranslate nohighlight">\(v_{7}\)</span> and <span class="math notranslate nohighlight">\(v_{8}\)</span>, with edges labelled <span class="math notranslate nohighlight">\(d\)</span>, back to <span class="math notranslate nohighlight">\(v_{2}\)</span> and <span class="math notranslate nohighlight">\(v_{6}\)</span> respectively.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080022262.png" />
Since there is a reduce on rule <span class="math notranslate nohighlight">\(C::=d\)</span> from both states at the top of the stack list we can perform both to get the new stack list shown below.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080023138.png" />
From state 5 there is a reduce on <span class="math notranslate nohighlight">\(S::=abC\)</span> so we pop the top 3 nodes off the first stack and create the new node, <span class="math notranslate nohighlight">\(v_{11}\)</span>, labelled 1, with an edge from <span class="math notranslate nohighlight">\(v_{11}\)</span> to <span class="math notranslate nohighlight">\(v_{0}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080023042.png" /></p>
<p>From state 7 there is a reduction on rule <span class="math notranslate nohighlight">\(S::=aBC\)</span>, so we pop the top 3 nodes off the second stack as well and create the new node, <span class="math notranslate nohighlight">\(v_{12}\)</span> as shown below.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080137046.png" />
Since all the input has been consumed and <span class="math notranslate nohighlight">\(v_{10}\)</span> and <span class="math notranslate nohighlight">\(v_{11}\)</span>, which are labelled by the accept state of the DFA, are at the top of the stack list the parse has succeeded.</p>
<p>Using a stack list to follow all parses of an ambiguous sentence can be very inefficient. If a state can be reached in several different ways, because of non-determinism, then there will be several duplicate stacks. Unfortunately, this can cause the number of stacks created to grow exponentially. In addition to this, because the stacks do not share any information with each other, if the tops of several stacks contain the same state then they continue to parse the remaining input in the same way until the duplicate states are popped off each stack.</p>
<p>Such redundant actions can be prevented with the use of a slightly modified structure called a Tree Structured Stack (TSS) [16]. When the tops of two or more stacks contain the same state, a single state is shared between each stack. This prevents duplicate parses of the same input being done.</p>
<p>For example, consider the parse of the string <span class="math notranslate nohighlight">\(abd\)</span> shown above. After duplicating the stack and performing the first reduction the next action is a shift on <span class="math notranslate nohighlight">\(d\)</span>. Since both stacks reach state 6 on the shift we can merge the nodes <span class="math notranslate nohighlight">\(v_{8}\)</span> and <span class="math notranslate nohighlight">\(v_{9}\)</span> to combine the stack list into a TSS.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080136266.png" />
Although this approach significantly improves the efficiency of the algorithm, it is still far from ideal - the number of stacks created can still grow exponentially. In both approaches discussed above, when a conflict in the parse table is encountered the entire stack is duplicated. However, it is often the case that separate stacks have the same nodes towards the bottom of the stack (the leaves of the TSS). Instead of duplicating a stack when a non-deterministic point in the parse is reached, the space required can be reduced by only splitting the necessary part of the stack. The resulting structure is called a Graph Structured Stack (GSS) [16]. The GSS constructed for the parse of the string <span class="math notranslate nohighlight">\(abd\)</span> is shown below.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080138099.png" /></p>
<p>The next section presents Tomita’s Generalised LR (GLR) algorithm that extends the standard LR parser by constructing a GSS during a parse.</p>
</section>
<section id="tomita-s-generalised-lr-parsing-algorithm">
<h2>4.2  Tomita’s Generalised LR parsing algorithm<a class="headerlink" href="#tomita-s-generalised-lr-parsing-algorithm" title="Permalink to this heading">¶</a></h2>
<p>In [16], Tomita presents five separate GLR algorithms which we shall refer to as Algorithms 0-4. The first four algorithms are recognisers and the fifth algorithm is the extension of Algorithm 3 to a parser. Algorithm 0 is defined to work for LR(1) grammars and is used to introduce the construction of the GSS. Algorithm 1 extends Algorithm 0 to work for non-LR(1) grammars without <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules. Algorithm 2 introduces a complex approach to deal with <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules and forms the basis of Algorithm 3 - the full version of the recognition algorithm. Algorithm 4 is the parser version of the GLR algorithm which constructs a shared packed parse forest representation of parse trees.</p>
<p>This section introduces Tomita’s recognition Algorithms 1 and 2. We begin by defining the central data structure that underpins all of Tomita’s algorithms - the GSS. We demonstrate the construction of the GSS for both algorithms and highlight some of the problems associated with each of the approaches. Algorithms 3 and 4 are discussed in Section 4.4.</p>
<section id="graph-structured-stacks">
<h3>4.2.1 Graph structured stacks<a class="headerlink" href="#graph-structured-stacks" title="Permalink to this heading">¶</a></h3>
<p>A Graph Structured Stack (GSS) is the central data structure that underpins all of Tomita’s GLR algorithms. An instance of a GSS is related to a specific grammar <span class="math notranslate nohighlight">\(\Gamma\)</span> and input string <span class="math notranslate nohighlight">\(a_{1}\dots a_{n}\)</span>. It is defined as a directed acyclic graph, containing two types of node: state nodes, labelled by the state numbers of the DFA for <span class="math notranslate nohighlight">\(\Gamma\)</span> and symbol nodes, labelled by <span class="math notranslate nohighlight">\(\Gamma\)</span>’s grammar symbols.</p>
<p>The state nodes are grouped together into <span class="math notranslate nohighlight">\(n+1\)</span> disjoint sets called <em>levels</em>. The GSS is constructed one level at a time. First all possible reductions are performed for the state nodes in the current level (the frontier), and then the next level is created as a result of applying shift actions. The first level is initialised with a state node labelled by the <span class="math notranslate nohighlight">\(DFA's\)</span> start state.</p>
<p>We represent a GSS graphically by drawing the state nodes as circular nodes and the symbol nodes are square nodes. To separate each of the levels we draw the state nodes of a given level in a single column labelled <span class="math notranslate nohighlight">\(U_{i}\)</span>, where <span class="math notranslate nohighlight">\(0\leq i\leq n\)</span>. The GSS is drawn from left to right, with the rightmost nodes representing the tops of each of the stacks.</p>
</section>
<section id="example-constructing-a-gss">
<h3>4.2.2 Example - constructing a GSS<a class="headerlink" href="#example-constructing-a-gss" title="Permalink to this heading">¶</a></h3>
<p>We shall describe how a GSS is constructed during the parse of a string <span class="math notranslate nohighlight">\(abc\)</span> with Grammar 4.1, whose DFA shown in Figure 4.1 and the associated parse table in Table 4.1. We shall refer to the parse table as <span class="math notranslate nohighlight">\(\mathcal{T}\)</span>.</p>
<p>The GSS is initialised with the state node, <span class="math notranslate nohighlight">\(v_{0}\)</span>, in level <span class="math notranslate nohighlight">\(U_{0}\)</span>. For each new state node constructed in the GSS we check to see what actions are applicable. We begin the parse by finding the shift action s2 in <span class="math notranslate nohighlight">\(\mathcal{T}(0,a)\)</span>. This triggers the creation of the next level, <span class="math notranslate nohighlight">\(U_{1}\)</span> for which we create the new node, <span class="math notranslate nohighlight">\(v_{1}\)</span>, labelled 2. We create a new symbol node, labelled <span class="math notranslate nohighlight">\(a\)</span>, and make it the successor of <span class="math notranslate nohighlight">\(v_{1}\)</span> and the predecessor of <span class="math notranslate nohighlight">\(v_{0}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080139126.png" /></p>
<p>We process <span class="math notranslate nohighlight">\(v_{1}\)</span> and find the shift action s3 in <span class="math notranslate nohighlight">\(\mathcal{T}(2,b)\)</span>. We construct the new node, <span class="math notranslate nohighlight">\(v_{2}\)</span> labelled 3 and add it to level <span class="math notranslate nohighlight">\(U_{2}\)</span>. We read the <span class="math notranslate nohighlight">\(b\)</span> from the input string, construct the new symbol node labelled <span class="math notranslate nohighlight">\(b\)</span> and make it the successor of <span class="math notranslate nohighlight">\(v_{2}\)</span> and the predecessor of <span class="math notranslate nohighlight">\(v_{1}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080139775.png" /></p>
<p>Next we process <span class="math notranslate nohighlight">\(v_{3}\)</span>. In <span class="math notranslate nohighlight">\(\mathcal{T}(3,c)\)</span> there is a shift/reduce conflict, s6/r3. Since the construction of the GSS is synchronised on the shift actions, we queue the shift, and continue by performing the reduction by rule 3, <span class="math notranslate nohighlight">\(B::=b\)</span>. Unlike the standard LR parser that removes states from the parse stack when a reduction is performed, a GLR algorithm does not remove nodes from the GSS<a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. Instead of popping nodes off the stack, we perform a traversal of all <em>reduction paths</em> of length 2, from node <span class="math notranslate nohighlight">\(v_{2}\)</span>, to find the target nodes of the reduction. In this case there is only one path, which leads to node <span class="math notranslate nohighlight">\(v_{1}\)</span>. We find the goto action, g4 <span class="math notranslate nohighlight">\(\in\mathcal{T}(2,B)\)</span>, and create the new state node, <span class="math notranslate nohighlight">\(v_{3}\)</span>, labelled 4 in the current level <span class="math notranslate nohighlight">\(U_{2}\)</span>. We then create the symbol node labelled <span class="math notranslate nohighlight">\(B\)</span> and make it the successor of <span class="math notranslate nohighlight">\(v_{3}\)</span> and the predecessor of <span class="math notranslate nohighlight">\(v_{1}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080140677.png" /></p>
<p>The only action associated with the newly created node, <span class="math notranslate nohighlight">\(v_{3}\)</span>, is the shift s6. Since we have processed all nodes in <span class="math notranslate nohighlight">\(U_{2}\)</span> and performed all possible reductions the current level is complete. So next we construct level <span class="math notranslate nohighlight">\(U_{3}\)</span> by performing the shift actions from <span class="math notranslate nohighlight">\(v_{2}\)</span> and <span class="math notranslate nohighlight">\(v_{3}\)</span>. We create the new node, <span class="math notranslate nohighlight">\(v_{4}\)</span>, labelled 6, in <span class="math notranslate nohighlight">\(U_{3}\)</span> and two new symbol nodes labelled <span class="math notranslate nohighlight">\(d\)</span>. We then add two paths of length 2 from <span class="math notranslate nohighlight">\(v_{4}\)</span>, one going to <span class="math notranslate nohighlight">\(v_{2}\)</span> and the other going to <span class="math notranslate nohighlight">\(v_{3}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080140236.png" /></p>
<p>At this point we have consumed all the input symbols and are left with the lookahead symbol <span class="math notranslate nohighlight">\(\$\)</span>. We process <span class="math notranslate nohighlight">\(v_{4}\)</span> and find the reduce action r4 <span class="math notranslate nohighlight">\(\in\mathcal{T}(6,\$)\)</span>. Since the right hand side of rule 4 contains one symbol we trace back paths of length 2 from <span class="math notranslate nohighlight">\(v_{4}\)</span>. In this case two possible paths exist; one reaching <span class="math notranslate nohighlight">\(v_{2}\)</span> and the other <span class="math notranslate nohighlight">\(v_{3}\)</span>. We create two new nodes, <span class="math notranslate nohighlight">\(v_{5}\)</span> and <span class="math notranslate nohighlight">\(v_{6}\)</span>, labelled with the goto states found in <span class="math notranslate nohighlight">\(\mathcal{T}(3,C)\)</span> and <span class="math notranslate nohighlight">\(\mathcal{T}(4,C)\)</span> respectively. We create two new symbol nodes, both labelled <span class="math notranslate nohighlight">\(C\)</span> and use them to create a path between <span class="math notranslate nohighlight">\(v_{5}\)</span> and <span class="math notranslate nohighlight">\(v_{2}\)</span> and <span class="math notranslate nohighlight">\(v_{6}\)</span> and <span class="math notranslate nohighlight">\(v_{3}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080143136.png" />
Processing both nodes <span class="math notranslate nohighlight">\(v_{5}\)</span> and <span class="math notranslate nohighlight">\(v_{6}\)</span> we see that the reduction r1 is applicable. The right hand side of rule 1 consists of 3 symbols, so we need to find the nodes at the end of the paths of length 6. Both reduction paths reach <span class="math notranslate nohighlight">\(v_{0}\)</span> and since the associated goto action is the same for both reductions we create one new node, <span class="math notranslate nohighlight">\(v_{7}\)</span>, labelled 1 in the current level. Only one symbol node labelled <span class="math notranslate nohighlight">\(S\)</span> is required, with a path from <span class="math notranslate nohighlight">\(v_{7}\)</span> to <span class="math notranslate nohighlight">\(v_{0}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080144040.png" /></p>
<p>Processing node <span class="math notranslate nohighlight">\(v_{7}\)</span> we find the accept action <span class="math notranslate nohighlight">\(acc\in\mathcal{T}(1,\$)\)</span>. Since we have consumed all of the input and processed all state nodes in the current level the input string <span class="math notranslate nohighlight">\(abc\)</span> is accepted.</p>
<p>Note that it is a property of the GSS that all symbol nodes pointed to by a state are labelled by the same grammar symbol.</p>
</section>
</section>
<section id="tomita-s-algorithm-1">
<h2>4.2.3 Tomita’s Algorithm 1<a class="headerlink" href="#tomita-s-algorithm-1" title="Permalink to this heading">¶</a></h2>
<p>Tomita’s Algorithm 1 basically works by constructing a GSS in the way we have described in the previous section. However, as is shown in the previous example there may be more than one node in the frontier of the GSS waiting to be processed. Tomita uses a special bookkeeping set, <span class="math notranslate nohighlight">\(\mathcal{A}\)</span>, to keep track of these newly created state nodes. A parse is performed by iterating over this set and finding all applicable actions for a given node. However, as it is possible for a node to have multiple applicable actions (as a result of a conflict in the parse table) two additional bookkeeping sets, <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>, are used to store any pending shifts and reductions. The set <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span> stores elements of the form <span class="math notranslate nohighlight">\((v,k)\)</span>, where <span class="math notranslate nohighlight">\(v\)</span> is the node labelled <span class="math notranslate nohighlight">\(h\)</span> that has a transition labelled by the next input symbol to a state <span class="math notranslate nohighlight">\(k\)</span> in the DFA.</p>
<p>Before describing the elements stored in the set <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> we discuss how reductions are performed in the GSS. Recall that the standard LR parser performs a reduction for a rule <span class="math notranslate nohighlight">\(A::=X_{1}\ldots X_{j}\)</span> by popping <span class="math notranslate nohighlight">\(j\)</span> symbols off the top of the stack. In comparison a reduction in a GLR parser is associated with a node in the frontier and requires all paths of length <span class="math notranslate nohighlight">\(2j\)</span> to be traced back from the given node. In the worst case this search may require <span class="math notranslate nohighlight">\(O(n^{j})\)</span> time.</p>
<p>The efficiency of Tomita’s algorithms stems from the fact that the same part of the input is not parsed more than once in the same way. In other words, each reduction path is only traversed once for each reduction. However, it is possible for a new edge to be added to an existing node in the frontier that has already performed its associated reductions. This new edge introduces a new reduction path that needs to be traversed for the parse to be correct. So as not to traverse the same path more than once Tomita stores elements of the form <span class="math notranslate nohighlight">\((w,t)\)</span>, where <span class="math notranslate nohighlight">\(t\)</span> is the rule number of the reduction in the set <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> and <span class="math notranslate nohighlight">\(w\)</span> is the first edge of the path down which reduction <span class="math notranslate nohighlight">\(t\)</span> is to be applied.</p>
<p>Below is the formal description of Tomita’s Algorithm 1, taken from [Tom86].</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080149856.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080150025.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080150273.png" /></p>
<section id="parsing-with-epsilon-rules">
<h3>4.2.4 Parsing with <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules<a class="headerlink" href="#parsing-with-epsilon-rules" title="Permalink to this heading">¶</a></h3>
<p>Tomita’s Algorithm 1 is defined to work on <span class="math notranslate nohighlight">\(\epsilon\)</span>-free grammars and hence does not contain the machinery to deal with <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules. However, by modifying the way reductions are performed, the algorithm can parse grammars containing <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules. Recall that when a new node, <span class="math notranslate nohighlight">\(v\)</span>, is created whose state contains an applicable reduction for a rule of the form <span class="math notranslate nohighlight">\(A::=\alpha\)</span>, the algorithm finds all nodes at the end of the paths of length <span class="math notranslate nohighlight">\(2\times|\alpha|-1\)</span> from the successors of <span class="math notranslate nohighlight">\(v\)</span>. Since <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules have length zero, an <span class="math notranslate nohighlight">\(\epsilon\)</span>-reduction does not require a path to be traversed.</p>
<p>Although it is trivial to extend Algorithm 1 to deal with <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules, the straightforward approach fails to parse certain grammars correctly. For example, consider Grammar 4.2 and the string <span class="math notranslate nohighlight">\(aab\)</span>. The associated LR(1) DFA is shown in Figure 4.2.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080151835.png" /></p>
<p>We begin the parse by creating <span class="math notranslate nohighlight">\(v_{0}\)</span> and adding it to <span class="math notranslate nohighlight">\(U_{0}\)</span> and the set <span class="math notranslate nohighlight">\(\mathcal{A}\)</span>. When <span class="math notranslate nohighlight">\(v_{0}\)</span> is processed in the Actor we only find a shift to state 3 on the first input symbol <span class="math notranslate nohighlight">\(a\)</span>. We create a new symbol node labelled <span class="math notranslate nohighlight">\(a\)</span> which we make a successor of <span class="math notranslate nohighlight">\(v_{1}\)</span> and a predecessor of <span class="math notranslate nohighlight">\(v_{0}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080151423.png" /></p>
<p>We continue in this way shifting the next two input symbols and constructing the GSS shown below.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080151949.png" /></p>
<p>Processing <span class="math notranslate nohighlight">\(v_{3}\)</span>, we find the reduction on rule 2, <span class="math notranslate nohighlight">\(S::=b\)</span>, which is applicable from state 2. From the only successor of <span class="math notranslate nohighlight">\(v_{3}\)</span>, the symbol node labelled <span class="math notranslate nohighlight">\(b\)</span>, we traverse a path of length one to <span class="math notranslate nohighlight">\(v_{2}\)</span>. We then create the new state node <span class="math notranslate nohighlight">\(v_{4}\)</span>, labelled <span class="math notranslate nohighlight">\(4\)</span>, and a new path of length two between <span class="math notranslate nohighlight">\(v_{4}\)</span> and <span class="math notranslate nohighlight">\(v_{2}\)</span> via a new symbol node labelled <span class="math notranslate nohighlight">\(S\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080152661.png" /></p>
<p>From state <span class="math notranslate nohighlight">\(4\)</span> there is only one applicable reduction on rule <span class="math notranslate nohighlight">\(3\)</span>, <span class="math notranslate nohighlight">\(B::=\epsilon\)</span>. Since the right hand side of the rule is <span class="math notranslate nohighlight">\(\epsilon\)</span>, we do not traverse a reduction path. This results in the creation of <span class="math notranslate nohighlight">\(v_{5}\)</span> with a path to <span class="math notranslate nohighlight">\(v_{4}\)</span> via a the new symbol node labelled <span class="math notranslate nohighlight">\(B\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080152471.png" /></p>
<p><img alt="" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080152648.png" />
Processing <span class="math notranslate nohighlight">\(v_{5}\)</span>, we find a reduction on rule <span class="math notranslate nohighlight">\(1\)</span>, <span class="math notranslate nohighlight">\(S::=aSB\)</span>. We trace back a path of length <span class="math notranslate nohighlight">\(5\)</span> to <span class="math notranslate nohighlight">\(v_{1}\)</span> from the successor of <span class="math notranslate nohighlight">\(v_{5}\)</span>. Since the node <span class="math notranslate nohighlight">\(v_{4}\)</span>, which is labelled by the goto state of the reduction, already exists in the frontier of the GSS a new path of length two is added from <span class="math notranslate nohighlight">\(v_{4}\)</span> to <span class="math notranslate nohighlight">\(v_{1}\)</span> via a new symbol node labelled <span class="math notranslate nohighlight">\(S\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080152846.png" /></p>
<p>At this point there are no nodes waiting to be processed and no actions are queued in either of the bookkeeping sets <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span> or <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>. Although all the input has been consumed the parse terminates in failure since there is not a state node in the frontier of the GSS that is labelled by the accept state of the DFA. This is clearly incorrect behaviour since the string <span class="math notranslate nohighlight">\(aab\)</span> is in the language of Grammar 4.2.</p>
<p>It turns out that the problem is caused by the new reduction paths created by nullable reductions. Recall that when a new edge is added from an existing node in the GSS, Algorithm 1 re-performs any reductions that have already been applied from <span class="math notranslate nohighlight">\(v\)</span>. However, in the above example the new path of length two from <span class="math notranslate nohighlight">\(v_{4}\)</span> to <span class="math notranslate nohighlight">\(v_{1}\)</span> did not create a new reduction path from <span class="math notranslate nohighlight">\(v_{4}\)</span>, but it did from <span class="math notranslate nohighlight">\(v_{5}\)</span>.</p>
<p>We discuss this problem in more detail in Chapter 5. Tomita deals with this problem in Algorithm 2 by introducing sub-levels to the GSS. When an <span class="math notranslate nohighlight">\(\epsilon\)</span>-reduction is performed a new sub-frontier is created and the node labelled by the goto state of the reduction is created in this new sub-frontier. Before presenting the formal specification of Algorithm 2, we demonstrate its operation using the above example once again.</p>
</section>
<section id="tomita-s-algorithm-2">
<h3>4.2.5 Tomita’s Algorithm 2<a class="headerlink" href="#tomita-s-algorithm-2" title="Permalink to this heading">¶</a></h3>
<p>Tomita’s Algorithm 2 creates sub-frontiers <span class="math notranslate nohighlight">\(U_{i,j}\)</span> in <span class="math notranslate nohighlight">\(U_{i}\)</span> when <span class="math notranslate nohighlight">\(\epsilon\)</span>-reductions are applied. To parse the string <span class="math notranslate nohighlight">\(aab\)</span> we begin by creating <span class="math notranslate nohighlight">\(v_{0}\)</span>, labelled with the start state of the DFA, in level <span class="math notranslate nohighlight">\(U_{0,0}\)</span>. The only applicable action from state 0 of the DFA is a shift to state 3 on the first input symbol, <span class="math notranslate nohighlight">\(a\)</span>. We read the <span class="math notranslate nohighlight">\(a\)</span> from the input string, create the symbol node labelled <span class="math notranslate nohighlight">\(a\)</span> and the state node <span class="math notranslate nohighlight">\(v_{1}\)</span>, labelled 3. We make the new symbol node a successor of <span class="math notranslate nohighlight">\(v_{1}\)</span> and a predecessor of <span class="math notranslate nohighlight">\(v_{0}\)</span>. The GSS constructed up to this point is shown below.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080152172.png" /></p>
<p>We continue in this way, reading the next two input symbols and constructing the GSS shown below.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080153317.png" /></p>
<p>At this point state 2 contains a reduction on rule <span class="math notranslate nohighlight">\(S::=b\)</span>. We perform the reduction by traversing a path of length two from <span class="math notranslate nohighlight">\(v_{3}\)</span> to <span class="math notranslate nohighlight">\(v_{2}\)</span>. Since there is no node labelled by the goto state of the reduction we create <span class="math notranslate nohighlight">\(v_{4}\)</span>, the symbol node labelled <span class="math notranslate nohighlight">\(S\)</span> and the new path from <span class="math notranslate nohighlight">\(v_{4}\)</span> to <span class="math notranslate nohighlight">\(v_{2}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080153077.png" /></p>
<p>The only applicable action in state 4 is the nullable reduction on rule <span class="math notranslate nohighlight">\(B::=\epsilon\)</span>. Since it is nullable reductions that cause new edges to be added to existing nodes, a new sub-frontier <span class="math notranslate nohighlight">\(U_{3,1}\)</span> is created. We create the symbol node labelled <span class="math notranslate nohighlight">\(B\)</span> and the state node, <span class="math notranslate nohighlight">\(v_{5}\)</span>, in <span class="math notranslate nohighlight">\(U_{3,1}\)</span>. We make the new symbol node a successor of <span class="math notranslate nohighlight">\(v_{5}\)</span> and a predecessor of <span class="math notranslate nohighlight">\(v_{4}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080153327.png" /></p>
<p>We then continue as normal processing any applicable actions from state 5. We trace back a path of length six for the reduction on rule <span class="math notranslate nohighlight">\(S::=aSB\)</span>. Because the reduction is performed from a state node in the sub-frontier <span class="math notranslate nohighlight">\(U_{3,1}\)</span> we also create the state node <span class="math notranslate nohighlight">\(v_{6}\)</span>, labelled by the goto state of the reduction in <span class="math notranslate nohighlight">\(U_{3,1}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080153140.png" /></p>
<p>From state 4 we can perform another nullable reduction on rule <span class="math notranslate nohighlight">\(B::=\epsilon\)</span>. As a result we create a new sub-frontier, <span class="math notranslate nohighlight">\(U_{3,2}\)</span>, and add, <span class="math notranslate nohighlight">\(v_{7}\)</span>, the state node labelled by the goto state of the reduction to it.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080153692.png" /></p>
<p>Performing the reduction from <span class="math notranslate nohighlight">\(v_{7}\)</span> on rule <span class="math notranslate nohighlight">\(S::=aSB\)</span>, we trace back a path to <span class="math notranslate nohighlight">\(v_{0}\)</span>. We create, <span class="math notranslate nohighlight">\(v_{8}\)</span>, labelled 1, and the symbol node labelled <span class="math notranslate nohighlight">\(S\)</span>. We make the symbol node a successor of <span class="math notranslate nohighlight">\(v_{8}\)</span> and a predecessor of <span class="math notranslate nohighlight">\(v_{0}\)</span>. Since <span class="math notranslate nohighlight">\(v_{8}\)</span> is labelled by the accept state of the DFA and we have consumed all the input string, the parse is successful. The final GSS constructed is shown below.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080154053.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080154820.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080155897.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080155972.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080157322.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080156392.png" /></p>
<section id="the-non-termination-of-algorithm-2">
<h4>The non-termination of Algorithm 2<a class="headerlink" href="#the-non-termination-of-algorithm-2" title="Permalink to this heading">¶</a></h4>
<p>Although Algorithm 2 is defined to work on grammars containing <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules, it can fail to terminate when parsing strings with hidden-left recursive grammars. For example, consider the parse for the string <span class="math notranslate nohighlight">\(ab\)</span> with Grammar 4.3 and the LR(1) DFA in Figure 4.3.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080157163.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080158767.png" />
We begin the parse, as usual, by creating <span class="math notranslate nohighlight">\(v_{0}\)</span> in level <span class="math notranslate nohighlight">\(U_{0,0}\)</span>. Since state <span class="math notranslate nohighlight">\(0\)</span> contains a shift/reduce conflict, we queue the shift and perform the reduction on rule <span class="math notranslate nohighlight">\(B::=\epsilon\)</span>. Since the reduction is nullable we construct a new sub-frontier <span class="math notranslate nohighlight">\(U_{0,1}\)</span> with the new state node, <span class="math notranslate nohighlight">\(v_{1}\)</span>, labelled <span class="math notranslate nohighlight">\(3\)</span> and a path of length two from <span class="math notranslate nohighlight">\(v_{1}\)</span> to <span class="math notranslate nohighlight">\(v_{0}\)</span>, via the new intermediate symbol node labelled <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080158468.png" /></p>
<p>State 3 contains another shift/reduce conflict, so we queue the shift and perform the reduction <span class="math notranslate nohighlight">\(B::=\epsilon\)</span> once again. Since this reduction is also nullable we create <span class="math notranslate nohighlight">\(U_{0,2}\)</span>, <span class="math notranslate nohighlight">\(v_{2}\)</span> and a path of length two from <span class="math notranslate nohighlight">\(v_{2}\)</span> to <span class="math notranslate nohighlight">\(v_{1}\)</span> via the intermediate symbol node <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080158152.png" /></p>
<p>Processing <span class="math notranslate nohighlight">\(v_{2}\)</span>, we find the same shift/reduce conflict in state 5; a shift on <span class="math notranslate nohighlight">\(b\)</span> and the nullable reduction on rule <span class="math notranslate nohighlight">\(B::=\epsilon\)</span>. Performing this reduction results in yet another new sub-frontier and another state node labelled 5. This process continues indefinitely preventing the algorithm from terminating.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080158118.png" /></p>
<p>In the next section we discuss a modification of Algorithm 2 that enables the parser to work for all context-free grammars.</p>
</section>
</section>
</section>
<section id="farshi-s-extension-of-algorithm-1">
<h2>4.3 Farshi’s extension of Algorithm 1<a class="headerlink" href="#farshi-s-extension-of-algorithm-1" title="Permalink to this heading">¶</a></h2>
<p>The non-termination of Tomita’s Algorithm 2 was first reported by Nozohoor-Farshi. In [10], Farshi attributes the problem of Algorithm 2 to the false assumption that only a finite number of nullable reductions can be applied between the shift of two consecutive input symbols. Instead of creating sub-frontiers for nullable reductions, Farshi introduces extra searching when a new edge is added from an existing node in the frontier of the GSS.</p>
<p>In this section we describe the operation of Farshi’s correction and highlight the extra costs involved. The formal specification of the algorithm is taken from [10]. The layout and notation of the algorithm is similar to that of Tomita’s, apart from the Reducer function which is renamed to Completer.</p>
<section id="farshi-s-recogniser">
<h3>Farshi’s recogniser<a class="headerlink" href="#farshi-s-recogniser" title="Permalink to this heading">¶</a></h3>
<p><strong>Variables</strong>
$<span class="math notranslate nohighlight">\(
\begin{array}{l}
	\Gamma: \ \text{The parse graph.} \\
	U_{i}: \text{The set of state vertices created just before shifting the input word } a_{i+1} .\\
	s_{0}: \ \text{The initial state of the parser.} \\
	\mathcal{A}: \ \text{The set of active nodes on which the parser will act.} \\
	\mathcal{Q}: \ \text{The set of shift operations to be carried out.} \\
	\mathcal{R}: \ \text{The set of reductions to be performed.} \\
\end{array}
\)</span>$
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080202600.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080202731.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080203188.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080204678.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080204521.png" /></p>
</section>
<section id="example-a-hidden-left-recursive-grammar">
<h3>4.3.1 Example - a hidden-left recursive grammar<a class="headerlink" href="#example-a-hidden-left-recursive-grammar" title="Permalink to this heading">¶</a></h3>
<p>Consider the parse of the string <span class="math notranslate nohighlight">\(ba\)</span> (with Grammar 4.3) that caused <span class="math notranslate nohighlight">\(\text{Tomita's Algorithm} 2\)</span> to fail to terminate in the previous section. We demonstrate how Farshi’s algorithm deals with hidden-left recursive grammars by tracing the construction of the <span class="math notranslate nohighlight">\(GSS\)</span>.</p>
<p>We create <span class="math notranslate nohighlight">\(v_{0}\)</span>, labelled by the start state of the <span class="math notranslate nohighlight">\(DFA\)</span>, in level <span class="math notranslate nohighlight">\(U_{0}\)</span>. Since there is a shift/reduce conflict in state 0, we queue the shift and perform the reduction on rule <span class="math notranslate nohighlight">\(B::=\epsilon\)</span>. The reduction is nullable so we create the new state node, <span class="math notranslate nohighlight">\(v_{1}\)</span> labelled 3, in the current level, and a path of length two from <span class="math notranslate nohighlight">\(v_{1}\)</span> to <span class="math notranslate nohighlight">\(v_{0}\)</span> via the new intermediate symbol node <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080205216.png" /></p>
<p>There is another shift/reduce conflict in state 3, so we queue the shift once again and perform the reduction on rule <span class="math notranslate nohighlight">\(B::=\epsilon\)</span>. As a result we create <span class="math notranslate nohighlight">\(v_{2}\)</span> in the current level and another symbol node labelled <span class="math notranslate nohighlight">\(B\)</span>. We make this new symbol node a successor of <span class="math notranslate nohighlight">\(v_{2}\)</span> and a predecessor of <span class="math notranslate nohighlight">\(v_{1}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080205202.png" />
There is the same shift/reduce conflict in state 5, so we perform the nullable reduction and queue the shift action again. However, because of the loop in state 5 of the DFA, caused by the hidden-left recursive rule <span class="math notranslate nohighlight">\(S::=BSa\)</span>, we create a cyclic path of length two from <span class="math notranslate nohighlight">\(v_{2}\)</span> to itself via a new symbol node labelled <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080212908.png" /></p>
<p>There are no further reductions that can be performed from any of the state nodes in level <span class="math notranslate nohighlight">\(U_{0}\)</span>, so we proceed to carry-out the queued shift actions. This results in two new state nodes, <span class="math notranslate nohighlight">\(v_{3}\)</span> and <span class="math notranslate nohighlight">\(v_{4}\)</span>, being created in level <span class="math notranslate nohighlight">\(U_{1}\)</span>, with paths of length two, via three separate symbol nodes labelled <span class="math notranslate nohighlight">\(b\)</span>, back to the appropriate nodes in level <span class="math notranslate nohighlight">\(U_{0}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080212956.png" /></p>
<p>From this point on Farshi’s algorithm behaves in the same way as Tomita’s Algorithm 2. Once all actions have been performed the GSS shown below is constructed.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080212350.png" /></p>
<p>Since <span class="math notranslate nohighlight">\(v_{9}\)</span> is labelled by the accept state of the DFA and we have consumed all the input string, we have successfully recognised <span class="math notranslate nohighlight">\(ba\)</span> as being in the language of Grammar 4.3.</p>
</section>
<section id="example-a-hidden-right-recursive-grammar">
<h3>4.3.2 Example - a hidden-right recursive grammar<a class="headerlink" href="#example-a-hidden-right-recursive-grammar" title="Permalink to this heading">¶</a></h3>
<p>It is claimed that Farshi’s algorithm “…works exactly like the original one [Tomita’s] in case of grammars that have no <span class="math notranslate nohighlight">\(\epsilon\)</span>-productions… [and] has no extra costs beyond that of the original algorithm.” [NF91, p.74].</p>
<p>Although it is possible to implement the algorithm so as not to incur the extra searching costs for <span class="math notranslate nohighlight">\(\epsilon\)</span>-free grammars the algorithmic description presented in [NF91] does not include any functionality to achieve it. The only indication that this is possible comes from the comment in the Completer function.</p>
<p>The extra searching costs introduced by Farshi’s modification can be high if done naively. The algorithm, as described in [15], searches all nodes in the current frontier that are not waiting to be processed, and finds any reduction paths that pass through the new node created as part of the original reduction. This extra searching to correct Tomita’s error for grammars containing right nullable rules effectively defeats the core of Tomita’s idea - reduced graph searching. This fix can be thought of as a brute force way to fixing the problem.</p>
<p>To highlight the extra searching introduced by Farshi’s algorithm we demonstrate its operation for the parse of the string <span class="math notranslate nohighlight">\(aab\)</span> with Grammar 4.2 shown on page 4.2. We begin by creating the start state, <span class="math notranslate nohighlight">\(v_{0}\)</span>, in <span class="math notranslate nohighlight">\(U_{0}\)</span>. We add <span class="math notranslate nohighlight">\(v_{0}\)</span> to the set <span class="math notranslate nohighlight">\(\mathcal{A}\)</span> and process it in the Actor. As there is only a shift to state <span class="math notranslate nohighlight">\(3\)</span>, from state <span class="math notranslate nohighlight">\(0\)</span> on an <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\((v_{0},3)\)</span> is added to <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span>. We then create the state node <span class="math notranslate nohighlight">\(v_{1}\)</span> in <span class="math notranslate nohighlight">\(U_{1}\)</span>, the symbol node labelled <span class="math notranslate nohighlight">\(a\)</span> and a path of length two from <span class="math notranslate nohighlight">\(v_{1}\)</span> to <span class="math notranslate nohighlight">\(v_{0}\)</span> via the symbol node.</p>
<p>We parse the next two input symbols in this way, creating the two new state nodes <span class="math notranslate nohighlight">\(v_{2}\)</span> and <span class="math notranslate nohighlight">\(v_{3}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080214225.png" /></p>
<p>When we process <span class="math notranslate nohighlight">\(v_{3}\)</span> in the Actor we find the reduction on rule <span class="math notranslate nohighlight">\(2\)</span>, (<span class="math notranslate nohighlight">\(S::=b\cdot\)</span>), in state <span class="math notranslate nohighlight">\(2\)</span>. We trace back a path of length two from <span class="math notranslate nohighlight">\(v_{3}\)</span> to <span class="math notranslate nohighlight">\(v_{2}\)</span> and add <span class="math notranslate nohighlight">\((v_{2},2)\)</span> to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>. We process the contents of <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> in the Completer which results in the new node, <span class="math notranslate nohighlight">\(v_{4}\)</span>, labelled <span class="math notranslate nohighlight">\(4\)</span>, being created in <span class="math notranslate nohighlight">\(U_{3}\)</span>, with a path of length two to <span class="math notranslate nohighlight">\(v_{2}\)</span> through a new symbol node labelled <span class="math notranslate nohighlight">\(S\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080214975.png" /></p>
<p>Processing <span class="math notranslate nohighlight">\(v_{4}\)</span> in the Actor we find an applicable reduction on rule <span class="math notranslate nohighlight">\(3\)</span>, (<span class="math notranslate nohighlight">\(B::=\cdot\)</span>). Since the reduction is nullable, we do not traverse any edges and add <span class="math notranslate nohighlight">\((v_{4},3)\)</span> to the set <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>. When we process <span class="math notranslate nohighlight">\((v_{4},3)\)</span> in the Completer we create the new node, <span class="math notranslate nohighlight">\(v_{5}\)</span>, labelled <span class="math notranslate nohighlight">\(5\)</span>, and add it to the set <span class="math notranslate nohighlight">\(\mathcal{A}\)</span> and <span class="math notranslate nohighlight">\(U_{3}\)</span>. We create the symbol node labelled <span class="math notranslate nohighlight">\(B\)</span> and a path of length two from <span class="math notranslate nohighlight">\(v_{5}\)</span> to <span class="math notranslate nohighlight">\(v_{4}\)</span> via the new symbol node.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080215894.png" /></p>
<p>When we process <span class="math notranslate nohighlight">\(v_{5}\)</span> we find the reduction on rule 1, <span class="math notranslate nohighlight">\((S::=aSB\cdot)\)</span>, in state 5. We trace back a path of length six to <span class="math notranslate nohighlight">\(v_{1}\)</span> and add <span class="math notranslate nohighlight">\((v_{1},1)\)</span> to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>. When we process <span class="math notranslate nohighlight">\((v_{1},1)\)</span> in the Completer, we find that there is already a node labelled 4 in the frontier of the GSS. As there is not a path of length two to <span class="math notranslate nohighlight">\(v_{1}\)</span> from <span class="math notranslate nohighlight">\(v_{4}\)</span>, we create one via a new symbol node labelled <span class="math notranslate nohighlight">\(S\)</span>. However, because we have added a new edge to an existing node of the GSS we need to ensure that no new reduction paths have been introduced from the other nodes in the frontier. This is achieved by effectively traversing all reduction paths from the existing nodes in the frontier and re-performing any reductions that go through the new edge.</p>
<p>It is not necessary to re-trace reduction paths from nodes that are still waiting to be processed, as they will be carried out later. However, since there are no nodes in the set <span class="math notranslate nohighlight">\(\mathcal{A}\)</span> at this point of our example, the set difference <span class="math notranslate nohighlight">\(U_{3}-\mathcal{A}\)</span>, results in all nodes in <span class="math notranslate nohighlight">\(U_{3}\)</span> being considered. We trace the paths:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(v_{3},v_{2}\)</span> for reduction <span class="math notranslate nohighlight">\((S::=b\cdot)\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(v_{5},v_{4},v_{2},v_{1}\)</span> for reduction <span class="math notranslate nohighlight">\((S::=aSB\cdot)\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(v_{5},v_{4},v_{1},v_{0}\)</span> for reduction <span class="math notranslate nohighlight">\((S::=aSB\cdot)\)</span>.</p></li>
</ul>
<p>Only the last traversal goes through the new edge between <span class="math notranslate nohighlight">\(v_{4}\)</span> and <span class="math notranslate nohighlight">\(v_{1}\)</span>, so we add <span class="math notranslate nohighlight">\((v_{0},1)\)</span> to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> for the reduction on rule 1.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080215575.png" /></p>
<p>When we perform the reduction in the Completer we create the new node, <span class="math notranslate nohighlight">\(v_{6}\)</span>, labelled 1, and the symbol node labelled <span class="math notranslate nohighlight">\(S\)</span> with a path from <span class="math notranslate nohighlight">\(v_{6}\)</span> to <span class="math notranslate nohighlight">\(v_{0}\)</span>. Since <span class="math notranslate nohighlight">\(v_{6}\)</span> is labelled by the accept state of the DFA and we have consumed all the input string, the parse terminates in success. The final GSS constructed is shown below.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080216003.png" /></p>
<p>In practice this searching can trigger considerable extra work, see Chapter 10 where we discuss some experiments. It turns out that it is trivial to improve the efficiency of the algorithm by limiting the searching to paths within the current level. This is possible as the new path created from the reduction has to leave the current frontier. As soon as a path being searched goes to a previous level and does not go through the new edge, that particular search can be terminated.</p>
<p>We have implemented both the naive and optimised versions of Farshi’s algorithm. We compare both versions to each other in Chapter 10.</p>
<p>In the next section we discuss the construction of derivations by GLR parsers, specifically focusing on Tomita’s approach and Rekers’ modifications.</p>
</section>
</section>
<section id="constructing-derivations">
<h2>4.4 Constructing derivations<a class="headerlink" href="#constructing-derivations" title="Permalink to this heading">¶</a></h2>
<p>The GLR algorithm finds all possible parses of an input string. This is because Tomita was interested in natural language processing which often has “temporarily or absolutely ambiguous input sentences” and hence requires this approach to deal with it. Tomita recognised the problem of ambiguous parsing leading to exponential time requirements. The number of parses of a sentence with an ambiguous grammar may grow exponentially with the size of the sentence [10]. Therefore an efficient parsing algorithm would still require exponential time just to print the exponential number of possible parse trees. The key is to use an efficient representation of the parse trees. Tomita achieved this through subtree sharing and local ambiguity packing of the parse forest.</p>
<p>In this section we define the structure used by Tomita to represent all derivations of an input string and then discuss his parsing algorithm and Rekers’ subsequent extension.</p>
<section id="shared-packed-parse-forests">
<h3>4.4.1 Shared packed parse forests<a class="headerlink" href="#shared-packed-parse-forests" title="Permalink to this heading">¶</a></h3>
<p>Local ambiguity occurs when there is a reduce/reduce conflict in the parse table. This makes it possible to reduce the same substring in more than one way which manifests itself in the parse tree as two or more nodes with the same label that have leaf nodes representing the same part of the input. A lot of local ambiguity can cause an exponential number of parse trees to be created. However, this can be controlled by combining all parse trees into one structure, taking advantage of sharing and packing of certain nodes, called a <em>Shared Packed Parse Forest</em> (SPPF). The parent nodes are merged into a new node and a packing node is made the parent of each of the subtrees.</p>
<p>For example, consider the ambiguous Grammar 4.4 (previously encountered on page 29), which defines the syntax of simple arithmetic expressions.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080603097.png" /></p>
<p>We can parse the string <span class="math notranslate nohighlight">\(a+a*a\)</span> in two different ways that represents the left and right associativity of the <span class="math notranslate nohighlight">\(*\)</span> symbol. The two parse trees are shown in Figure 4.4.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080216467.png" /></p>
<p>The amount of space required to represent both trees can be significantly reduced by using the SPPF shown in Figure 4.5.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080217728.png" /></p>
<p>If two trees have the same subtree for a substring <span class="math notranslate nohighlight">\(a_{j}\dots a_{i}\)</span> then that subtree can be shared, as is shown in Figure 4.6.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080218418.png" /></p>
<p>If two trees have a node labelled by the same non-terminal that derives the same substring, <span class="math notranslate nohighlight">\(a_{j}\ldots a_{i}\)</span>, in two different ways then that node can be packed and the two subtrees added as alternates under the newly packed node. For example, see Figure 4.7 below.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080218932.png" /></p>
<p>Although the SPPF provides an efficient representation of multiple parse trees it is not the most compact representation possible. It has been shown that maximal sharing can be achieved by “sharing the corresponding prefixes of right hand sides” [1]. This approach involves sharing all nodes that are labelled by the same symbol and derive terminals that are lexicographically the same. However, with this representation the yield of the derivation tree may not be the input string. This technique has been successfully adopted by the SGLR parser in the <span class="math notranslate nohighlight">\(\text{Asf+Sdf}\)</span> Meta-Environment [<span class="math notranslate nohighlight">\(vdBvDH^{+}01\)</span>]. A description of the ATerm library, the data structure that efficiently implements the maximally shared SPPF, is given in [10].</p>
<p><strong>Cyclic grammars</strong></p>
<p>A cyclic grammar contains a nonterminal that can derive itself, <span class="math notranslate nohighlight">\(A\stackrel{{*}}{{\Rightarrow}}A\)</span>. Cyclic grammars can have an infinite number of derivations for certain strings in their language. For example, the parse of the string <span class="math notranslate nohighlight">\(a\)</span> with Grammar 4.5 results in the construction of an infinite number of parse trees of the form shown in Figure 4.8.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080604989.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080221236.png" />
Farshi introduced cycles into the GSS so that his algorithm could be used to parse strings with cyclic grammars. We introduce cycles into the SPPF so that they can be used to represent an infinite number of parse trees. The SPPF representing the parse trees of the above parse is shown in Figure 4.9.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080221551.png" /></p>
</section>
<section id="tomita-s-algorithm-4">
<h3>4.4.2 Tomita’s Algorithm 4<a class="headerlink" href="#tomita-s-algorithm-4" title="Permalink to this heading">¶</a></h3>
<p>Tomita’s Algorithm 3 is a recogniser, based on Algorithm 2, that incorporates sharing of symbol nodes into the GSS. Tomita extends Algorithm 3 to a parser, Algorithm 4, by introducing the necessary SPPF construction. Recall that Algorithm 2 can fail to terminate on hidden-left recursive grammars. This behaviour is inherited by Algorithm 4. We discuss the operation of Algorithm 4 to illustrate Tomita’s approach to SPPF generation.</p>
<p>The GSS’s constructed by Tomita’s algorithms contain exactly one symbol node between every connected pair of state nodes. Although the symbol nodes do not perform any specific function in the recognition algorithms, they play an important role in Algorithm 4 - they correspond directly to the nodes in the SPPF.</p>
<p>The amount of space required to represent all derivations of an ambiguous sentence is controlled by the sharing and packing of the nodes in the SPPF. Since the GSS symbol nodes have a one-to-one correspondence with the nodes in the SPPF, some of the symbol nodes in the GSS need to be shared. We demonstrate the construction of an SPPF for the string <span class="math notranslate nohighlight">\(abd\)</span> whose Grammar 4.1 and associated LR(1) DFA are shown on page 4.1.</p>
<p>We begin the parse by creating the node <span class="math notranslate nohighlight">\(v_{0}\)</span>, labelled by the start state of the DFA. The only applicable action from state <span class="math notranslate nohighlight">\(0\)</span> is a shift to state <span class="math notranslate nohighlight">\(2\)</span> for the first symbol on the input string, <span class="math notranslate nohighlight">\(a\)</span>. We perform the shift by creating the new state node, <span class="math notranslate nohighlight">\(v_{1}\)</span>, and the new SPPF node, <span class="math notranslate nohighlight">\(w_{0}\)</span>, labelled <span class="math notranslate nohighlight">\(a\)</span>. We use <span class="math notranslate nohighlight">\(w_{0}\)</span> as the symbol node on the path from <span class="math notranslate nohighlight">\(v_{1}\)</span> to <span class="math notranslate nohighlight">\(v_{0}\)</span>. To make the example easier to read we draw the SPPF separately from the GSS and only label the GSS symbol nodes with the node of the SPPF.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080222235.png" /></p>
<p>We continue the parse by processing <span class="math notranslate nohighlight">\(v_{1}\)</span> and performing the associated shift to state <span class="math notranslate nohighlight">\(3\)</span>. We create the new state node, <span class="math notranslate nohighlight">\(v_{2}\)</span>, labelled <span class="math notranslate nohighlight">\(3\)</span>, and the new SPPF node, <span class="math notranslate nohighlight">\(w_{1}\)</span>, labelled <span class="math notranslate nohighlight">\(b\)</span>, which we use as the symbol node between <span class="math notranslate nohighlight">\(v_{1}\)</span> and <span class="math notranslate nohighlight">\(v_{2}\)</span>.</p>
<p>From state <span class="math notranslate nohighlight">\(3\)</span> there is a shift and a reduce action applicable. We queue the shift to state <span class="math notranslate nohighlight">\(6\)</span> and perform the reduction on rule <span class="math notranslate nohighlight">\(3\)</span>, <span class="math notranslate nohighlight">\(B::=b\)</span>. We begin by tracing back a path of length one from the symbol node <span class="math notranslate nohighlight">\(w_{1}\)</span> to <span class="math notranslate nohighlight">\(v_{1}\)</span>. We then create a new state node, <span class="math notranslate nohighlight">\(v_{3}\)</span>, labelled <span class="math notranslate nohighlight">\(4\)</span> and the new SPPF node, <span class="math notranslate nohighlight">\(w_{2}\)</span>, labelled <span class="math notranslate nohighlight">\(B\)</span>. We make <span class="math notranslate nohighlight">\(w_{1}\)</span> the child of <span class="math notranslate nohighlight">\(w_{2}\)</span> and use <span class="math notranslate nohighlight">\(w_{2}\)</span> as the symbol node on the path between <span class="math notranslate nohighlight">\(v_{3}\)</span> and <span class="math notranslate nohighlight">\(v_{1}\)</span>. We process <span class="math notranslate nohighlight">\(v_{3}\)</span> and queue the applicable shift action to state <span class="math notranslate nohighlight">\(6\)</span> which completes the construction of <span class="math notranslate nohighlight">\(U_{2}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080222711.png" /></p>
<p>When we perform the two queued shift actions to state <span class="math notranslate nohighlight">\(6\)</span>, we create a new state node, <span class="math notranslate nohighlight">\(v_{4}\)</span>, and a new SPPF node <span class="math notranslate nohighlight">\(w_{3}\)</span>, labelled <span class="math notranslate nohighlight">\(d\)</span>. We use <span class="math notranslate nohighlight">\(w_{3}\)</span> as the symbol node on the path between both <span class="math notranslate nohighlight">\(v_{4}\)</span> and <span class="math notranslate nohighlight">\(v_{2}\)</span>, and <span class="math notranslate nohighlight">\(v_{4}\)</span> and <span class="math notranslate nohighlight">\(v_{3}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080223179.png" /></p>
<p>From state 6 there is a reduction on rule 4, <span class="math notranslate nohighlight">\(C::=d\)</span>, applicable. We trace back the two separate paths of length one from the symbol nodes labelled <span class="math notranslate nohighlight">\(w_{3}\)</span> which lead to <span class="math notranslate nohighlight">\(v_{2}\)</span> and <span class="math notranslate nohighlight">\(v_{3}\)</span> respectively. For the reduction path that leads to <span class="math notranslate nohighlight">\(v_{2}\)</span> we create the new state node <span class="math notranslate nohighlight">\(v_{5}\)</span>, labelled 5, and the new SPPF node, <span class="math notranslate nohighlight">\(w_{5}\)</span>, labelled <span class="math notranslate nohighlight">\(C\)</span>. We make the symbol node, <span class="math notranslate nohighlight">\(w_{3}\)</span>, the child of <span class="math notranslate nohighlight">\(w_{5}\)</span> and use <span class="math notranslate nohighlight">\(w_{5}\)</span> as the symbol node between <span class="math notranslate nohighlight">\(v_{5}\)</span> and <span class="math notranslate nohighlight">\(v_{2}\)</span>. For the second reduction path we create the state node <span class="math notranslate nohighlight">\(v_{6}\)</span> and another SPPF node <span class="math notranslate nohighlight">\(w_{6}\)</span>, also labelled <span class="math notranslate nohighlight">\(C\)</span> with <span class="math notranslate nohighlight">\(w_{3}\)</span> as its child.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080223664.png" /></p>
<p>Processing <span class="math notranslate nohighlight">\(v_{5}\)</span> we find that the reduction on rule 1, <span class="math notranslate nohighlight">\(S::=abC\)</span>, is applicable. We trace back a path of length five from <span class="math notranslate nohighlight">\(w_{5}\)</span> to <span class="math notranslate nohighlight">\(v_{0}\)</span> and collect the SPPF nodes <span class="math notranslate nohighlight">\(w_{1}\)</span> and <span class="math notranslate nohighlight">\(w_{0}\)</span> encountered on the traversal. We create the new state node <span class="math notranslate nohighlight">\(v_{7}\)</span>, labelled 1, and the new SPPF node, <span class="math notranslate nohighlight">\(w_{7}\)</span>, labelled <span class="math notranslate nohighlight">\(S\)</span>. We make <span class="math notranslate nohighlight">\(w_{0},w_{1}\)</span> and <span class="math notranslate nohighlight">\(w_{5}\)</span> the children of <span class="math notranslate nohighlight">\(w_{7}\)</span> and use <span class="math notranslate nohighlight">\(w_{7}\)</span> as the symbol node on the path between <span class="math notranslate nohighlight">\(v_{7}\)</span> and <span class="math notranslate nohighlight">\(v_{0}\)</span>.</p>
<p><img alt="" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080223185.png" /></p>
<p>Then we process <span class="math notranslate nohighlight">\(v_{6}\)</span> and find the reduction on rule 2, <span class="math notranslate nohighlight">\(S::=aBC\)</span> that needs to be performed. We trace back a path of length five from <span class="math notranslate nohighlight">\(w_{6}\)</span> to <span class="math notranslate nohighlight">\(v_{0}\)</span> and collect the SPPF nodes <span class="math notranslate nohighlight">\(w_{2}\)</span> and <span class="math notranslate nohighlight">\(w_{0}\)</span>. Because there is already the state node <span class="math notranslate nohighlight">\(v_{7}\)</span> that is labelled 1, with an edge to <span class="math notranslate nohighlight">\(v_{0}\)</span> we have encountered an ambiguity in the parse. Since the SPPF node, <span class="math notranslate nohighlight">\(w_{7}\)</span>, that is used as the symbol node on the path between <span class="math notranslate nohighlight">\(v_{7}\)</span> and <span class="math notranslate nohighlight">\(v_{0}\)</span> is labelled <span class="math notranslate nohighlight">\(S\)</span> and derives the same portion of input as this reduction, we can use packing nodes below <span class="math notranslate nohighlight">\(w_{7}\)</span> to represent both derivations.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080224191.png" /></p>
<p>We have parsed all the symbols on the input string and since <span class="math notranslate nohighlight">\(v_{7}\)</span> is labelled by the accept state of the DFA, the parse terminates in success.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080224467.png" /></p>
<p>Although the parse was successful the final SPPF is not as compact as possible; there are still several nodes that can be shared. Since the SPPF is encoded into the symbol nodes of the GSS, sharing can only be incorporated into the SPPF if the symbol nodes are shared in the GSS. Recall that two nodes in the SPPF can be shared if the are labelled by the same symbol and have the same subtree below them.</p>
<p>If a symbol node <span class="math notranslate nohighlight">\(v\)</span> has a parent node in level <span class="math notranslate nohighlight">\(U_{i}\)</span> and a child node in a level <span class="math notranslate nohighlight">\(U_{j}\)</span> then it derives <span class="math notranslate nohighlight">\(a_{j+1}\ldots a_{i}\)</span> of the input string <span class="math notranslate nohighlight">\(a_{1}\ldots a_{n}\)</span>[15]. Although such SPPF nodes can always be shared, it is not always possible to share the corresponding symbol node in the GSS. For example, if the two symbol nodes labelled <span class="math notranslate nohighlight">\(A\)</span> in the GSS below are shared, then two spurious reduction paths will be introduced</p>
<p>Although the increased sharing of symbol nodes reduces the size of the GSS and SPPF, it comes at a cost. Before creating a new symbol node with a parent node <span class="math notranslate nohighlight">\(v\)</span>, all symbol nodes directly linked to <span class="math notranslate nohighlight">\(v\)</span> must be searched to see if one reaches the same level as the one we want to create. So as to reduce the amount of searching performed in this way, Tomita only shares symbol nodes that are created during the same reduction. Specifically only symbol nodes that share the same reduction path up to the penultimate node are merged.</p>
<p>We shall now describe Rekers’ parser version of Farshi’s algorithm which generates more node sharing in the SPPF. It is this approach that we use in the RNGLR version of Tomita’s algorithm described in Chapter 5.</p>
</section>
<section id="rekers-sppf-construction">
<h3>4.4.3 Rekers’ SPPF construction<a class="headerlink" href="#rekers-sppf-construction" title="Permalink to this heading">¶</a></h3>
<p>It is often assumed that one of Rekers’ contributions was a correction of Tomita’s Algorithm 2. However, upon closer inspection it is clear that it is Farshi’s and not Tomita’s algorithm that forms the basis of Rekers’ parser. Rekers’ true contribution</p>
<p>Figure 4.10: A GSS with incorrect symbol node sharing.</p>
<p>is the extension of Farshi’s algorithm to a parser and the improved sharing of nodes in the SPPF.</p>
<p>Farshi only provides his algorithm as a recogniser, but he claims it is possible to extend it to a parser “…in a way similar to that of [Tomita]…” [11]. However, it is not straightforward to incorporate all the sharing as defined by Algorithm 3. For example, Farshi’s algorithm finds the target of a reduction path as soon as a reduction is encountered which prevents the sharing of the non-terminal symbol nodes.</p>
<p>In order to achieve better sharing of nodes in the SPPF Rekers does not use symbol nodes in the GSS. Instead of having a one-to-one correspondence between the GSS and SPPF, Rekers labels each of the edges in the GSS with a pointer to the associated SPPF node. This enables more nodes in the SPPF to be shared without worrying about spurious reduction paths being introduced as a result.</p>
<p>To achieve this sharing, it is necessary to remember the SPPF nodes that are constructed at the current step of the algorithm. Recall that nodes in the SPPF can only be shared if they are labelled by the same symbol and derive (or cover) the same portion of the input string. A naive approach to ensuring that a given node derives the same portion of the input would involve the traversal of its entire sub-tree. Rekers presents a more efficient approach that requires the SPPF nodes to be labelled by the start and end position of the string covered. This reduces the cost of the check to a comparison of the start and end positions.</p>
<p>Rekers’ SPPF representation contains three types of node: symbol nodes, term nodes and rule nodes. The term nodes are labelled by terminal symbols and form the leaves of the SPPF. The symbol nodes are labelled by non-terminals and have edges to rule nodes. The rule nodes are labelled by grammar rules and are equivalent to Tomita’s packing nodes. A major difference to Tomita’s representation is that every symbol node has at least one rule node as a child, even if the symbol node only has one set of children. As a result the SPPF produced by Rekers for a non-ambiguous parse is larger than that produced by Tomita.</p>
</section>
<section id="rekers-parser-with-improved-sharing-in-the-sppf">
<h3><strong>Rekers’ parser with improved sharing in the SPPF</strong><a class="headerlink" href="#rekers-parser-with-improved-sharing-in-the-sppf" title="Permalink to this heading">¶</a></h3>
<p>The formal description of Rekers’ parsing algorithm is taken from [10]. Although the core of Rekers’ algorithm is similar to Farshi’s, it uses slightly different notation. The sets <em>for-actor</em> and <em>for-shifter</em> are used instead of <span class="math notranslate nohighlight">\(\mathcal{A}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span> respectively and the set <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> is not used explicitly. Also, the functions Get-Rulenode, Cover, Add-Rulenode and Get-Symbolnode are added to achieve the increased sharing in the SPPF. Note that trees that derive <span class="math notranslate nohighlight">\(\epsilon\)</span> do not cover any part of the input string. The function Cover handles this situation by always returning a non-empty position.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080232832.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080229929.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080230928.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080230438.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080231323.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080232203.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080232411.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080232041.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080233600.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080234475.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080234185.png" /></p>
<p>We demonstrate the operation of Rekers’ algorithm on the parse of the string <span class="math notranslate nohighlight">\(abd\)</span> whose Grammar 4.1 and associated LR(1) DFA are shown on page 52.</p>
<p>To begin the parse we create the new state node <span class="math notranslate nohighlight">\(v_{0}\)</span>, labelled by the start state of the DFA, and add it to <em>active-parsers</em>. We set the <em>current-token</em> to <span class="math notranslate nohighlight">\(a\)</span> and the <em>position</em> to 1. Then we execute the Parseword function, which leads us to copy <span class="math notranslate nohighlight">\(v_{0}\)</span> into the <em>for-actor</em> and process it in the Actor function. Since there is shift to state 2 from state 0 in the DFA we add <span class="math notranslate nohighlight">\(\langle v_{0},2\rangle\)</span> to <em>for-shifter</em>. We then perform the shift action in the Shifter which results in a new SPPF node <span class="math notranslate nohighlight">\(w_{0}\)</span>, labelled <span class="math notranslate nohighlight">\(a\)</span><span class="math notranslate nohighlight">\(\langle 1,1\rangle\)</span> being created and used to label the edge between the new node <span class="math notranslate nohighlight">\(v_{1}\)</span> and <span class="math notranslate nohighlight">\(v_{0}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080234266.png" /></p>
<p>We continue by setting the <em>current-token</em> to <span class="math notranslate nohighlight">\(b\)</span> and the <em>position</em> to 2 and then follow the same process as before to shift the input symbol <span class="math notranslate nohighlight">\(b\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080234853.png" /></p>
<p>When we come to process <span class="math notranslate nohighlight">\(v_{2}\)</span> in the Actor we find a shift/reduce conflict associated with state 3 on the current lookahead symbol <span class="math notranslate nohighlight">\(d\)</span>. We add <span class="math notranslate nohighlight">\(\langle v_{2},6\rangle\)</span> to <em>for-shifter</em>, but before applying the shift, we perform the reduction on rule <span class="math notranslate nohighlight">\(B::=b\)</span> by executing the Do-Reductions function.</p>
<p>We trace a path of length one from <span class="math notranslate nohighlight">\(v_{2}\)</span> to <span class="math notranslate nohighlight">\(v_{1}\)</span>, collecting the SPPF node that labels the edge traversed, and then execute the Reducer function. In the Reducer we use the Get-Rulenode function to find any existing rule nodes in the SPPF that derive the same portion of the input string. Since there is none, the new rule node labelled <span class="math notranslate nohighlight">\(B::=b\ \langle 2,2\rangle\)</span> is created. We continue by creating the new GSS node <span class="math notranslate nohighlight">\(v_{3}\)</span> labelled <span class="math notranslate nohighlight">\(4\)</span>.</p>
<p>Before we create a new symbol node in the SPPF we execute the Get-Symbolnode function to ensure that a node does not already exist that can be shared. No node is found so we create the new node <span class="math notranslate nohighlight">\(w_{2}\)</span> and use it to label the edge between <span class="math notranslate nohighlight">\(v_{3}\)</span> and <span class="math notranslate nohighlight">\(v_{1}\)</span>.</p>
<p>To ensure that the new node <span class="math notranslate nohighlight">\(v_{3}\)</span> is processed we add it to <em>active-parsers</em> and <em>for-actor</em>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080235589.png" /></p>
<p>Processing <span class="math notranslate nohighlight">\(v_{3}\)</span> in the Actor func1tion we find another shift action to state <span class="math notranslate nohighlight">\(6\)</span>. We add <span class="math notranslate nohighlight">\(\langle v_{3},6\rangle\)</span> to <em>for-shifter</em> and then proceed to perform the two queued shifts in the Shifter function. This results in the creation of the new GSS node <span class="math notranslate nohighlight">\(v_{4}\)</span> labelled <span class="math notranslate nohighlight">\(6\)</span>, with two edges back to <span class="math notranslate nohighlight">\(v_{2}\)</span> and <span class="math notranslate nohighlight">\(v_{3}\)</span> labelled with a pointer to the new SPPF node <span class="math notranslate nohighlight">\(w_{3}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080235319.png" /></p>
<p>Processing <span class="math notranslate nohighlight">\(v_{4}\)</span> in the Actor function we find a reduction on rule <span class="math notranslate nohighlight">\(C::=d\)</span>. There are two different paths of length one that can be traced back from <span class="math notranslate nohighlight">\(v_{4}\)</span> in the Do-Reductions function. For each path we collect the SPPF node that labels the edge traversed and execute the Reducer function.</p>
<p>In the first execution of the Reducer we create a new rule node labelled <span class="math notranslate nohighlight">\(C::=d\ \langle 3,3\rangle\)</span> using the Get-Rulenode function and then create the new GSS node, <span class="math notranslate nohighlight">\(v_{5}\)</span>, labelled <span class="math notranslate nohighlight">\(5\)</span>. Since there does not already exist an SPPF symbol node labelled <span class="math notranslate nohighlight">\(C\ \langle 3,3\rangle\)</span> we create <span class="math notranslate nohighlight">\(w_{4}\)</span> and use a pointer to it to label the edge between <span class="math notranslate nohighlight">\(v_{5}\)</span> and <span class="math notranslate nohighlight">\(v_{2}\)</span>. We also add <span class="math notranslate nohighlight">\(v_{5}\)</span> to the <em>active-parsers</em> and <em>for-actor</em> sets.</p>
<p>In the second execution of the Reducer we find the rule node labelled <span class="math notranslate nohighlight">\(C::=d\ \langle 3,3\rangle\)</span> that has the same set of children as the reduction we are performing. We create the new GSS node <span class="math notranslate nohighlight">\(v_{6}\)</span>, labelled <span class="math notranslate nohighlight">\(7\)</span> and pass the existing rule node into the Get-Symbolnode function. However, since there is already the symbol node <span class="math notranslate nohighlight">\(w_{4}\)</span> that is labelled by the same non-terminal and derives the same portion of the input, we do not create a new node. We use a pointer to <span class="math notranslate nohighlight">\(w_{4}\)</span> to label the new edge between <span class="math notranslate nohighlight">\(v_{6}\)</span> and <span class="math notranslate nohighlight">\(v_{3}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080235037.png" /></p>
<p>At this point the <em>for-actor</em> contains the two GSS nodes <span class="math notranslate nohighlight">\(v_{5}\)</span> and <span class="math notranslate nohighlight">\(v_{6}\)</span>. Processing the first of the nodes we find the reduction on rule <span class="math notranslate nohighlight">\(S::=abC\)</span>. We trace back a path of length three from <span class="math notranslate nohighlight">\(v_{5}\)</span> and collect the SPPF nodes <span class="math notranslate nohighlight">\(w_{4},w_{1},w_{0}\)</span> that label the edges traversed. We then create a new rule node labelled <span class="math notranslate nohighlight">\(S::=abC\)</span><span class="math notranslate nohighlight">\(\langle 1,3\rangle\)</span> and make it the parent of the nodes previously collected. We create the new node <span class="math notranslate nohighlight">\(v_{7}\)</span>, labelled <span class="math notranslate nohighlight">\(1\)</span>, and the new symbol node <span class="math notranslate nohighlight">\(w_{5}\)</span>, labelled <span class="math notranslate nohighlight">\(S\)</span><span class="math notranslate nohighlight">\(\langle 1,3\rangle\)</span>, as a parent of the new rule node created. We use a pointer to <span class="math notranslate nohighlight">\(w_{5}\)</span> to label the edge between <span class="math notranslate nohighlight">\(v_{7}\)</span> and <span class="math notranslate nohighlight">\(v_{0}\)</span> and add <span class="math notranslate nohighlight">\(v_{7}\)</span> to the <em>active-parsers</em> and <em>for-actor</em> sets.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080235183.png" /></p>
<p>When we process <span class="math notranslate nohighlight">\(v_{6}\)</span> we find another reduction on rule <span class="math notranslate nohighlight">\(S::=aBC\)</span>. We trace back a path of length three to <span class="math notranslate nohighlight">\(v_{0}\)</span> and collect the SPPF nodes <span class="math notranslate nohighlight">\(w_{0},w_{2},w_{4}\)</span> that label the edges traversed. We create the new rule node labelled <span class="math notranslate nohighlight">\(S::=aBC\)</span><span class="math notranslate nohighlight">\(\langle 1,3\rangle\)</span> and make it the parent of the previously collected SPPF nodes. However, we do not create a new state node in the GSS since <span class="math notranslate nohighlight">\(v_{7}\)</span> is labelled by the goto state of the current reduction. The existence of an edge from <span class="math notranslate nohighlight">\(v_{7}\)</span> to <span class="math notranslate nohighlight">\(v_{0}\)</span> indicates an ambiguity in the parse. As a result we add the rule node created for this reduction as a child of <span class="math notranslate nohighlight">\(w_{5}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080236705.png" /></p>
<p>The only action associated to the state that labels <span class="math notranslate nohighlight">\(v_{7}\)</span> is the accept action. Since all the input has been consumed the parse terminates in success and returns <span class="math notranslate nohighlight">\(w_{5}\)</span> as the root of the SPPF.</p>
<p>It is clear that Rekers’ SPPF construction produces more compact SPPF’s than Tomita’s Algorithm 4. This is because Rekers’ algorithm is able to share more symbol nodes in the GSS than Tomita’s algorithm. However, to achieve this extra sharing more searching is required which causes a significant overhead in the parsing process.</p>
</section>
</section>
<section id="summary">
<h2>4.5 Summary<a class="headerlink" href="#summary" title="Permalink to this heading">¶</a></h2>
<p>In this chapter we have introduced Tomita’s <span class="math notranslate nohighlight">\(\text{GLR}\)</span> parsing technique. The recognition Algorithms 1 and 2 were discussed in detail. We demonstrated the construction of the <span class="math notranslate nohighlight">\(\text{GSS}\)</span> using Algorithm 1, and illustrated how a straightforward extension to deal with grammars containing <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules fails to parse certain grammars correctly. The operation of Algorithm 2 was then examined and its non-termination for hidden-left recursive grammars was demonstrated. The extension of Algorithm 1 due to Farshi was discussed in detail and the extra costs involved were highlighted.</p>
<p>Finally, Tomita’s Algorithm 4 was presented that constructs an SPPF representation of multiple derivation trees and Rekers’ extension of Farshi’s algorithm was introduced.</p>
<p>Chapter 10 presents the experimental results of a naive and optimised implementation of Farshi’s recogniser for grammars which trigger worst case behaviour and several programming language grammars and strings.</p>
<p>The next chapter presents the <span class="math notranslate nohighlight">\(\text{RNGLR}\)</span> algorithm that correctly parses all context-free grammars using a modified <span class="math notranslate nohighlight">\(\text{LR}\)</span> parse table. The <span class="math notranslate nohighlight">\(\text{RNGLR}\)</span> parser incorporates some of Rekers’ sharing into the <span class="math notranslate nohighlight">\(\text{SPPF}\)</span>, but reduces the amount of searching required.</p>
<hr class="footnotes docutils" />
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Although it is possible to perform garbage collection to remove ‘dead’ nodes (nodes that can no longer be reached on a path through the GSS from the current level) we do not address the issue here. For a technique that implements such an approach see [14].</p>
</aside>
</aside>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="3%20The%20development%20of%20generalised%20parsing.html" class="btn btn-neutral float-left" title="3. The development of generalised parsing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="5%20Right%20Nulled%20Generalised%20LR%20parsing.html" class="btn btn-neutral float-right" title="5. Right Nulled Generalised LR parsing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, xrtero.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>