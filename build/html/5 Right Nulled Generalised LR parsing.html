<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>5. Right Nulled Generalised LR parsing &mdash; Generalised LR parsing algorithms  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="canonical" href="https://www.xrtero.com/book/glr/5 Right Nulled Generalised LR parsing.html" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=b3ba4146"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="6.Binary Right Nulled Generalised LR parsing" href="6%20Binary%20Right%20Nulled%20Generalised%20LR%20parsing.html" />
    <link rel="prev" title="4. Generalised LR parsing" href="4%20Generalised%20LR%20parsing.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Generalised LR parsing algorithms
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1%20Introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="2%20%20Recognition%20and%20parsing.html">2. Recognition and parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="3%20The%20development%20of%20generalised%20parsing.html">3. The development of generalised parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="4%20Generalised%20LR%20parsing.html">4. Generalised LR parsing</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">5. Right Nulled Generalised LR parsing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#tomita-s-algorithm-1e">5.1 Tomita’s Algorithm 1e</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example-a-hidden-left-recursive-grammar">5.1.1 Example - a hidden-left recursive grammar</a></li>
<li class="toctree-l3"><a class="reference internal" href="#paths-in-the-gss">5.1.2 Paths in the GSS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-an-incorrect-parse">Example - an incorrect parse</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#right-nulled-parse-tables">5.2 Right Nulled parse tables</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reducing-non-determinism">5.3 Reducing non-determinism</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-rnglr-recognition-algorithm">5.4 The RNGLR recognition algorithm</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rnglr-recogniser">RNGLR recogniser</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-rnglr-parsing-algorithm">5.5 The RNGLR parsing algorithm</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rnglr-parser">RNGLR parser</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#resolvability">5.6 Resolvability</a></li>
<li class="toctree-l2"><a class="reference internal" href="#summary">5.7 Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="6%20Binary%20Right%20Nulled%20Generalised%20LR%20parsing.html">6.Binary Right Nulled Generalised LR parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="7%20Reduction%20Incorporated%20Generalised%20LR%20parsing.html">7.Reduction Incorporated Generalised LR parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="8%20Other%20approaches%20to%20generalised%20parsing.html">8 Other approaches to generalised parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="9%20Some%20generalised%20parser%20generators.html">9. Some generalised parser generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="10%20Experimental%20investigation.html">10. Experimental investigation</a></li>
<li class="toctree-l1"><a class="reference internal" href="11%20Concluding%20remarks.html">11. Concluding remarks</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Generalised LR parsing algorithms</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">5. Right Nulled Generalised LR parsing</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/5 Right Nulled Generalised LR parsing.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="right-nulled-generalised-lr-parsing">
<h1>5. Right Nulled Generalised LR parsing<a class="headerlink" href="#right-nulled-generalised-lr-parsing" title="Permalink to this heading">¶</a></h1>
<p>Tomita’s Algorithm 1 can fail to terminate when parsing strings in the language of grammars with hidden-right recursion and Algorithm 2 can fail on grammars with hidden-left recursion. In Chapter 4 we considered Farshi’s extension to Tomita’s Algorithm 1 that increases the searching required during the construction of the GSS, but which is able to parse all context-free grammars. This chapter presents an algorithm capable of parsing all context-free grammars without the increase in searching costs.</p>
<p>It is clear that Tomita was aware of the problems associated with Algorithm 1 as he restricted its use to <span class="math notranslate nohighlight">\(\epsilon\)</span>-free grammars. It is not unusual to exclude <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules from parsing algorithms as difficulties are often caused by them; for instance the CYK algorithm requires grammars to be in Chomsky Normal Form. One of the reasons for using <span class="math notranslate nohighlight">\(\epsilon\)</span> in grammars is that many languages can be defined naturally using <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules while the <span class="math notranslate nohighlight">\(\epsilon\)</span>-free alternatives are often less compact and not as intuitive. Well known alg
orithms exist [1] that can remove <span class="math notranslate nohighlight">\(\epsilon\)</span> from grammars, but parsers that depend on this technique build parse trees related to the modified grammar. Another approach [13] that performs automatic removal of <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules during a parse is discussed in Chapter 8.</p>
<p>This chapter presents a modification to the LR DFA’s that allow Tomita’s Algorithm 1 to parse all context-free grammars including those with <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules. We discuss Algorithm 1 on <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules in detail and examine some grammars that cause the parser to fail. A modification to the parse table is then given that causes the algorithm to work correctly. The RNGLR algorithm that parses strings using the modified parse table more efficiently than Algorithm 1 on <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules is then presented both as a recogniser and then as a parser. Finally, we discuss ways to reduce the extra non-determinism introduced by the modification made to the parse table.</p>
<section id="tomita-s-algorithm-1e">
<h2>5.1 Tomita’s Algorithm 1e<a class="headerlink" href="#tomita-s-algorithm-1e" title="Permalink to this heading">¶</a></h2>
<p>Algorithm 1 provides a clear exposition of Tomita’s ideas. Unfortunately it cannot be used to parse natural language grammars as they often contain <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules. Tomita’s Algorithm 2 includes a complicated procedure for dealing with <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules which fails to terminate on grammars containing hidden-left recursion. The algorithm below, which we have called Algorithm 1e, is a straightforward extension to Algorithm 1 to include <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules, which works correctly for hidden-left recursive grammars, but may fail on grammars with hidden-right recursion. We begin this section by describing the modifications made to Algorithm 1 to allow <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules to be handled.</p>
<p>It is straight-forward to modify Tomita’s Algorithm 1 so that it can handle grammars containing <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules. The two main changes that need to be made are in the Actor and Reducer functions. When an <span class="math notranslate nohighlight">\(\epsilon\)</span> reduce action <span class="math notranslate nohighlight">\(rX\)</span> from a state <span class="math notranslate nohighlight">\(v\)</span> is found by the Actor, <span class="math notranslate nohighlight">\((v,X)\)</span> is added to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> instead of <span class="math notranslate nohighlight">\((u,X)\)</span>, where <span class="math notranslate nohighlight">\(u\)</span> are the successors of <span class="math notranslate nohighlight">\(v\)</span>. Since <span class="math notranslate nohighlight">\(\epsilon\)</span> reductions do not require any states to be popped off the stack, no reduction paths are traced in the Reducer.</p>
<p>It has already been shown, in Chapter 4, that it is possible to add a new edge to an existing state in the current level of the GSS. In this case the reductions from the existing state need to be applied down the newly created reduction path. However, not all reductions need to be re-done. Since <span class="math notranslate nohighlight">\(\epsilon\)</span> reductions do not pop any states off the stack, no new reduction path is added by the addition of the new edge. Because we store all pending reductions in the set <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>, and all <span class="math notranslate nohighlight">\(\epsilon\)</span> reductions are added to it when a new state is created, we can safely assume that if the <span class="math notranslate nohighlight">\(\epsilon\)</span> reductions have not already been done, they eventually will. Therefore no <span class="math notranslate nohighlight">\(\epsilon\)</span> reductions are added to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> when a new edge is added to an existing state. This modification was added to Tomita’s Algorithm 3, and since we have extended Algorithm 1 to allow <span class="math notranslate nohighlight">\(\epsilon\)</span> grammars to be parsed we have included this modification to Algorithm 1e as well.</p>
<p>Tomita’s original algorithms build GSS’s with symbol nodes between state nodes. Algorithm 1e does not include the symbol nodes, but in our diagrams we shall label the edges to make the GSS’s easier to visualise. As we shall see in Section 5.5 this approach also allows more compact SPPF’s to be generated.</p>
<p>To allow a closer comparison to the algorithms we introduce later we have changed the layout of Algorithm 1e and the format of the actions in the parse table: instead of using <span class="math notranslate nohighlight">\(sk\)</span> and <span class="math notranslate nohighlight">\(gk\)</span> to represent the shift and goto actions, we use <span class="math notranslate nohighlight">\(pk\)</span> for both; instead of using <span class="math notranslate nohighlight">\(rj\)</span> to represent a reduction on rule <span class="math notranslate nohighlight">\(j\)</span>, we use <span class="math notranslate nohighlight">\(r(X,m)\)</span> where <span class="math notranslate nohighlight">\(X\)</span> is the left hand non-terminal of rule <span class="math notranslate nohighlight">\(j\)</span> and <span class="math notranslate nohighlight">\(m\)</span> is the length of <span class="math notranslate nohighlight">\(j\)</span>’s right hand side.</p>
<p><strong>Algorithm 1e</strong></p>
<p><strong>input data</strong> start state <span class="math notranslate nohighlight">\(S_{S}\)</span>, accept state <span class="math notranslate nohighlight">\(S_{A}\)</span>, parse table <span class="math notranslate nohighlight">\(\mathcal{T}\)</span>, input string <span class="math notranslate nohighlight">\(a_{1}...a_{n}\)</span></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080311524.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080312477.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080313611.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080313437.png" /></p>
<section id="example-a-hidden-left-recursive-grammar">
<h3>5.1.1 Example - a hidden-left recursive grammar<a class="headerlink" href="#example-a-hidden-left-recursive-grammar" title="Permalink to this heading">¶</a></h3>
<p>We revisit Example 4.2.6, which causes Algorithm 2 to fail to terminate, and show the operation of Algorithm 1e. We repeat Grammar 4.3 and use the LR(1) parse table below.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080600245.png" /></p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{|c||c|c|c|c|c|}\hline&amp;\text{a}&amp;\text{b}&amp;\$&amp;\text{B}&amp;\text{S} \\ \hline\hline 0&amp;\text{p2/r(B,0)}&amp;&amp;\text{p3}&amp;\text{p1}\\ \hline 1&amp;\text{acc}&amp;&amp;\text{}&amp;\\ \hline 2&amp;\text{r(S,1)}&amp;&amp;\\ \hline 3&amp;\text{p6/r(B,0)}&amp;&amp;\text{p5}&amp;\text{p4}\\ \hline 4&amp;\text{s7}&amp;&amp;\\ \hline 5&amp;\text{p6/r(B,0)}&amp;&amp;\text{p5}&amp;\text{p8}\\ \hline 6&amp;\text{r(S,1)}&amp;&amp;\\ \hline 7&amp;\text{r(S,3)}&amp;&amp;\\ \hline 8&amp;\text{p9}&amp;&amp;\\ \hline 9&amp;\text{r(S,3)}&amp;&amp;\\ \hline\end{array}\end{split}\]</div>
<p>We shall use Algorithm 1e to construct the GSS for the string <span class="math notranslate nohighlight">\(ba\)</span>. The start state <span class="math notranslate nohighlight">\(v_{0}\)</span> labelled 0 is created in <span class="math notranslate nohighlight">\(U_{0}\)</span> and the reduction <span class="math notranslate nohighlight">\((v_{0},3)\)</span> is added to the set <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> and <span class="math notranslate nohighlight">\((v_{0},2)\)</span> to the set <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span>. Then <span class="math notranslate nohighlight">\((v_{0},3)\)</span> is removed from <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> which causes state <span class="math notranslate nohighlight">\(v_{1}\)</span> labelled 3 and an edge <span class="math notranslate nohighlight">\((v_{1},v_{0})\)</span> labelled <span class="math notranslate nohighlight">\(B\)</span> to be created and <span class="math notranslate nohighlight">\((v_{1},3)\)</span> to be added to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> and <span class="math notranslate nohighlight">\((v_{1},6)\)</span>to <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span>. When <span class="math notranslate nohighlight">\((v_{1},3)\)</span> is removed, state <span class="math notranslate nohighlight">\(v_{2}\)</span> labelled <span class="math notranslate nohighlight">\(5\)</span> and an edge <span class="math notranslate nohighlight">\((v_{2},v_{1})\)</span> labelled <span class="math notranslate nohighlight">\(B\)</span> are created and <span class="math notranslate nohighlight">\((v_{2},3)\)</span> is added to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> and <span class="math notranslate nohighlight">\((v_{2},6)\)</span> to <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span>. Removing <span class="math notranslate nohighlight">\((v_{2},3)\)</span> causes a cyclic edge to be created on state <span class="math notranslate nohighlight">\(5\)</span> also labelled <span class="math notranslate nohighlight">\(B\)</span>. The rightmost GSS in Figure 5.1, whose nodes have children within the same level, demonstrates the effect of <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules in the grammar. Notice the creation of the cycle in node <span class="math notranslate nohighlight">\(v_{2}\)</span> that causes the algorithm to terminate in the case of hidden-left recursion.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080314668.png" /></p>
<p>At this point no other elements are in the sets <span class="math notranslate nohighlight">\(\mathcal{A}\)</span> or <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> so we enter the Shifter which results in the following GSS being constructed.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080314051.png" /></p>
<p>When the Shifter has completed, the set <span class="math notranslate nohighlight">\(\mathcal{A}\)</span> contains the elements <span class="math notranslate nohighlight">\(\{v_{3},v_{4}\}\)</span>. We remove <span class="math notranslate nohighlight">\(v_{3}\)</span> and do nothing as there are no actions in <span class="math notranslate nohighlight">\(\mathcal{T}(2,a)\)</span>. When <span class="math notranslate nohighlight">\(v_{4}\)</span> is removed and processed, <span class="math notranslate nohighlight">\((v_{1},2)\)</span> and <span class="math notranslate nohighlight">\((v_{2},2)\)</span> are added to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> because of the reduction in <span class="math notranslate nohighlight">\(\mathcal{T}(6,a)\)</span>. When <span class="math notranslate nohighlight">\((v_{1},2)\)</span> is processed by the Reducer, state <span class="math notranslate nohighlight">\(v_{5}\)</span> labelled <span class="math notranslate nohighlight">\(4\)</span> and an edge <span class="math notranslate nohighlight">\((v_{5},v_{1})\)</span> labelled S are created in <span class="math notranslate nohighlight">\(U_{1}\)</span>, and <span class="math notranslate nohighlight">\((v_{5},7)\)</span> is added to <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span>. Then <span class="math notranslate nohighlight">\((v_{2},2)\)</span> is removed from <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> which results in a new state <span class="math notranslate nohighlight">\(v_{6}\)</span> labelled <span class="math notranslate nohighlight">\(8\)</span> being created, with an edge <span class="math notranslate nohighlight">\((v_{6},v_{2})\)</span> labelled S. The element <span class="math notranslate nohighlight">\((v_{6},9)\)</span> is also added to the set <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080314708.png" /></p>
<p>As there are no other elements in <span class="math notranslate nohighlight">\(\mathcal{A}\)</span> or <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> the Shifter is entered and the new states <span class="math notranslate nohighlight">\(v_{7}\)</span> and <span class="math notranslate nohighlight">\(v_{8}\)</span> labelled <span class="math notranslate nohighlight">\(7\)</span> and <span class="math notranslate nohighlight">\(9\)</span> are created in <span class="math notranslate nohighlight">\(U_{2}\)</span> with edges <span class="math notranslate nohighlight">\((v_{7},v_{5})\)</span> and <span class="math notranslate nohighlight">\((v_{8},v_{6})\)</span> respectively.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080314709.png" /></p>
<p>As the set <span class="math notranslate nohighlight">\(\mathcal{A}\)</span> is now <span class="math notranslate nohighlight">\(\{v_{7},v_{8}\}\)</span> the Actor removes and processes state <span class="math notranslate nohighlight">\(v_{7}\)</span> which causes it to add <span class="math notranslate nohighlight">\((v_{5},1)\)</span> to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>. State <span class="math notranslate nohighlight">\(v_{8}\)</span> is then removed, but it has no effect as there are no actions in <span class="math notranslate nohighlight">\(\mathcal{T}(9,\$)\)</span>. When <span class="math notranslate nohighlight">\((v_{5},1)\)</span> is processed by the Reducer a path of length <span class="math notranslate nohighlight">\(2\)</span> is traced back in the GSS to state <span class="math notranslate nohighlight">\(v_{0}\)</span>. The goto state in <span class="math notranslate nohighlight">\(\mathcal{T}(0,S)\)</span> is <span class="math notranslate nohighlight">\(1\)</span>, so the state <span class="math notranslate nohighlight">\(v_{9}\)</span> labelled <span class="math notranslate nohighlight">\(1\)</span> with an edge <span class="math notranslate nohighlight">\((v_{9},v_{0})\)</span> is created in <span class="math notranslate nohighlight">\(U_{2}\)</span> and also added to the set <span class="math notranslate nohighlight">\(\mathcal{A}\)</span>. The Actor then removes <span class="math notranslate nohighlight">\(v_{9}\)</span> and looks in <span class="math notranslate nohighlight">\(\mathcal{T}(1,\$)\)</span> to find the accept state, which indicates that the parse succeeded and that the string <span class="math notranslate nohighlight">\(ba\)</span> is in the language of Grammar 4.3. Figure 5.2 shows the final GSS constructed by Algorithm 1e.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080314101.png" /></p>
</section>
<section id="paths-in-the-gss">
<h3>5.1.2 Paths in the GSS<a class="headerlink" href="#paths-in-the-gss" title="Permalink to this heading">¶</a></h3>
<p>Algorithm 1 ensures that a reduction is only applied down a certain reduction path once. This is achieved by queueing the first edge of the path and the associated rule of the reduction in the set <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> when a new edge is created in the GSS. If a new edge is added to an existing node, any applicable reductions are applied down this new reduction path. For this approach to be successful it is essential that the new edge cannot be added to the middle of an existing reduction path. This is achieved by Algorithm 1 since all new edges created have their source node in the frontier and their target in a previous level of the GSS. However, the modification of Algorithm 1e to deal with <span class="math notranslate nohighlight">\(\epsilon\)</span>-rules allows edges to be created whose source and target nodes are in the same level. As a result of this, certain grammars can cause a new edge to be added to the middle of an existing reduction path. We illustrate this with the following example.</p>
</section>
<section id="example-an-incorrect-parse">
<h3>Example - an incorrect parse<a class="headerlink" href="#example-an-incorrect-parse" title="Permalink to this heading">¶</a></h3>
<p>Consider Grammar 5.1 and the associated LR(1) DFA in Figure 5.3 (previously encountered on page 5.1).</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080446112.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080446422.png" /></p>
<p>We shall use Algorithm 1e to construct the GSS for the string <span class="math notranslate nohighlight">\(aab\)</span>. We begin by creating the start state, <span class="math notranslate nohighlight">\(v_{0}\)</span>, in <span class="math notranslate nohighlight">\(U_{0}\)</span> and look up the actions in <span class="math notranslate nohighlight">\(\mathcal{T}(0,a)\)</span>. As there is only a shift to state 3, <span class="math notranslate nohighlight">\((v_{0},3)\)</span> is added to <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span> and ultimately results in state <span class="math notranslate nohighlight">\(v_{1}\)</span>, and the edge <span class="math notranslate nohighlight">\((v_{1},v_{0})\)</span> being created in <span class="math notranslate nohighlight">\(U_{1}\)</span>. The Actor then processes <span class="math notranslate nohighlight">\(v_{1}\)</span> and adds <span class="math notranslate nohighlight">\((v_{1},3)\)</span> to <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span>.</p>
<p>This results in a new state labelled 3 being created in <span class="math notranslate nohighlight">\(U_{2}\)</span> and the edge <span class="math notranslate nohighlight">\((v_{2},v_{1})\)</span> being added to the GSS. After processing <span class="math notranslate nohighlight">\(v_{2}\)</span> the state <span class="math notranslate nohighlight">\(v_{3}\)</span> labelled 2 and the edge <span class="math notranslate nohighlight">\((v_{3},v_{2})\)</span> is created.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080446194.png" /></p>
<p>When the Actor processes <span class="math notranslate nohighlight">\(v_{3}\)</span> it finds a reduce action in <span class="math notranslate nohighlight">\(\mathcal{T}(2,\$)\)</span> which it adds to the set <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> as <span class="math notranslate nohighlight">\((v_{2},2)\)</span>. The Reducer then removes <span class="math notranslate nohighlight">\((v_{2},2)\)</span> and creates the state <span class="math notranslate nohighlight">\(v_{4}\)</span> labelled 4 and the edge <span class="math notranslate nohighlight">\((v_{4},v_{2})\)</span>. Processing <span class="math notranslate nohighlight">\(v_{4}\)</span> results in <span class="math notranslate nohighlight">\((v_{4},3)\)</span> being added to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> which leads to the new state <span class="math notranslate nohighlight">\(v_{5}\)</span> labelled 5 and the edge <span class="math notranslate nohighlight">\((v_{5},v_{4})\)</span> labelled B being added to <span class="math notranslate nohighlight">\(U_{3}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080447291.png" /></p>
<p>When the new state <span class="math notranslate nohighlight">\(v_{5}\)</span> is processed a reduce action is found in <span class="math notranslate nohighlight">\(\mathcal{T}(5,\$)\)</span> which is added to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> as <span class="math notranslate nohighlight">\((v_{4},1)\)</span>. This reduction is traced back to <span class="math notranslate nohighlight">\(v_{1}\)</span> whose goto state is 4. As a state already exists in <span class="math notranslate nohighlight">\(U_{3}\)</span> labelled 4, a new edge <span class="math notranslate nohighlight">\((v_{4},v_{1})\)</span> labelled S is added to the GSS. Because a new edge is added to an existing node, the reduction from <span class="math notranslate nohighlight">\(v_{4}\)</span> is re-done, but as there is already a state labelled 5 and an edge <span class="math notranslate nohighlight">\((v_{5},v_{4})\)</span> in the current level, nothing is done.</p>
<p>At this point all the sets are empty so <span class="math notranslate nohighlight">\(U_{3}\)</span> is searched for the accept state, which is labelled 1. As no state labelled 1 exists in <span class="math notranslate nohighlight">\(U_{3}\)</span> Algorithm 1e returns false as the result to the parse even though <span class="math notranslate nohighlight">\(aab\)</span> is in the language of Grammar 4.2.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080447725.png" /></p>
<p>It turns out that some grammars with right nullable rules (rules of the form <span class="math notranslate nohighlight">\(A::=\alpha\beta\)</span> where <span class="math notranslate nohighlight">\(\beta\stackrel{{*}}{{\Rightarrow}}\epsilon\)</span>) can be successfully parsed by Algorithm 1e when the ordering of reductions is carefully chosen. However, grammars such as 4.2 that contain hidden-right recursion will always fail to parse some sentences in their language [15].</p>
<p>The next section presents a modification that can be made to the parse table, which will enable Algorithm 1e to correctly parse all context-free grammars.</p>
</section>
</section>
<section id="right-nulled-parse-tables">
<h2>5.2 Right Nulled parse tables<a class="headerlink" href="#right-nulled-parse-tables" title="Permalink to this heading">¶</a></h2>
<p>In order to allow Algorithm 1e to correctly parse all context-free grammars, a slightly modified parse table is built from the standard DFA in the following way. In addition to the standard reductions, we add reductions on right nullable rules, that is rules of the form <span class="math notranslate nohighlight">\(A::=\alpha\beta\)</span> where <span class="math notranslate nohighlight">\(\beta\stackrel{{*}}{{\Rightarrow}}\epsilon\)</span>.</p>
<p>If the DFA has a transition from state <span class="math notranslate nohighlight">\(h\)</span> to state <span class="math notranslate nohighlight">\(k\)</span> on the symbol <span class="math notranslate nohighlight">\(a\)</span> then <span class="math notranslate nohighlight">\(pk\)</span> is added to <span class="math notranslate nohighlight">\(\mathcal{T}(h,a)\)</span> instead of <span class="math notranslate nohighlight">\(sk\)</span> or <span class="math notranslate nohighlight">\(gk\)</span> if <span class="math notranslate nohighlight">\(a\)</span> is a terminal or non-terminal respectively. If state <span class="math notranslate nohighlight">\(h\)</span> includes an item of the form <span class="math notranslate nohighlight">\((A::=x_{1}\ldots x_{m}\cdot B_{1}\ldots B_{t},a)\)</span> where <span class="math notranslate nohighlight">\(A\neq S^{\prime}\)</span> and <span class="math notranslate nohighlight">\(t=0\)</span> or <span class="math notranslate nohighlight">\(B_{j}\stackrel{{*}}{{\Rightarrow}}\epsilon\)</span> for all <span class="math notranslate nohighlight">\(0\leq j\leq t\)</span>, then <span class="math notranslate nohighlight">\(r(A,m)\)</span> is added to <span class="math notranslate nohighlight">\(\mathcal{T}(h,a)\)</span>. If state <span class="math notranslate nohighlight">\(h\)</span> contains an item <span class="math notranslate nohighlight">\((S^{\prime}::=S\cdot,\$)\)</span> then <span class="math notranslate nohighlight">\(acc\)</span> is added to <span class="math notranslate nohighlight">\(\mathcal{T}(h,\$)\)</span> and if <span class="math notranslate nohighlight">\(S^{\prime}\stackrel{{*}}{{\Rightarrow}}\epsilon\)</span> then <span class="math notranslate nohighlight">\(acc\)</span> is also added to <span class="math notranslate nohighlight">\(\mathcal{T}(0,\$)\)</span>. We call this type of parse table a Right Nulled (RN) parse table.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080448293.png" /></p>
<p>Our approach takes advantage of the fact that no input is consumed when an <span class="math notranslate nohighlight">\(\epsilon\)</span> is parsed. By performing the part of the right nullable reduction that does derive a portion of the input string we ensure that no new edges can be added to the middle of an existing reduction path. Clearly this prevents a reduction path being missed by a state in the sequence of nullable reductions.</p>
<p>It is possible to think that because nullable reductions do not consume any input it is safe not to apply them at all. Unfortunately this can cause problems which are discussed in detail in Section 5.3.</p>
<p>We note here that there are other parsing optimisations, such as [1], that have been proposed that require <span class="math notranslate nohighlight">\(\epsilon\)</span> reductions to be taken account of at parser generation time. So if an item <span class="math notranslate nohighlight">\(A::=\alpha\cdot B\beta\in U_{i}\)</span> and <span class="math notranslate nohighlight">\(B\stackrel{{*}}{{\Rightarrow}}\epsilon\)</span> the item <span class="math notranslate nohighlight">\(A::=\alpha B\cdot\beta\)</span> is added to <span class="math notranslate nohighlight">\(U_{i}\)</span>. This is not the same as the right nullable reductions in RN parse tables.</p>
<p>Although the RN parse table enables Algorithm 1e to work correctly for all context-free grammars, see [11] for a proof of correctness, it contains more conflicts than its LR(1) counterpart. The next section presents a method to remove many of these conflicts introduced by the addition of right nullable reductions.</p>
</section>
<section id="reducing-non-determinism">
<h2>5.3 Reducing non-determinism<a class="headerlink" href="#reducing-non-determinism" title="Permalink to this heading">¶</a></h2>
<p>An undesirable side effect caused by the inclusion of the right nulled reductions in the RN parse table is a possible increase of non-determinism. As more reductions are added, it is possible that more reduce/reduce conflicts will occur (see Chapter 10).</p>
<p>Since our technique for correctly parsing hidden-right recursive grammars involves performing nullable reductions at the earliest point possible, one may hypothesise that the short circuited <span class="math notranslate nohighlight">\(\epsilon\)</span> reductions can be removed from the table to reduce the non-determinism. Unfortunately this is not always possible because <span class="math notranslate nohighlight">\(\epsilon\)</span> reductions may also include other useful derivations that do consume some input symbols.</p>
<p>For example, consider Grammar 5.2, the corresponding DFA in Figure 5.4 and the RN parse table 5.3.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080601154.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080449917.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080449674.png" /></p>
<p>The LR(1) parse table is already non-deterministic, but the number of conflicts is increased when the RN reduction <span class="math notranslate nohighlight">\(r(A,2)\)</span> is added to state 6. This will result in an increase in the amount of graph searching performed for certain parses such as the string <span class="math notranslate nohighlight">\(aabd\)</span>. Although the extra searching can be avoided by removing the <span class="math notranslate nohighlight">\(\epsilon\)</span> reduction <span class="math notranslate nohighlight">\(r(B,0)\)</span> from state 6, there are some strings that Algorithm 1 would then incorrectly fail to parse. For example, consider the parse of the string <span class="math notranslate nohighlight">\(aabdd\)</span> using parse table 5.3 and Algorithm 1.</p>
<p>Once we have parsed the first three input symbols and performed the reduction <span class="math notranslate nohighlight">\(r(A,1)\)</span> from state <span class="math notranslate nohighlight">\(v_{3}\)</span> we have the following GSS.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080449999.png" /></p>
<p>Performing the RN reduction <span class="math notranslate nohighlight">\(r(A,2)\)</span> from state <span class="math notranslate nohighlight">\(v_{4}\)</span> causes the new edge between <span class="math notranslate nohighlight">\(v_{4}\)</span> and <span class="math notranslate nohighlight">\(v_{1}\)</span> to be created. This new edge introduces a new reduction path from <span class="math notranslate nohighlight">\(v_{4}\)</span> to <span class="math notranslate nohighlight">\(v_{0}\)</span>, so we create <span class="math notranslate nohighlight">\(v_{5}\)</span> and add an edge between it and <span class="math notranslate nohighlight">\(v_{0}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080449518.png" /></p>
<p>From state 2 there is a shift to state 5, so we create the new state node <span class="math notranslate nohighlight">\(v_{7}\)</span> and the edge between <span class="math notranslate nohighlight">\(v_{7}\)</span> and <span class="math notranslate nohighlight">\(v_{5}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080450575.png" /></p>
<p>By not performing the <span class="math notranslate nohighlight">\(\epsilon\)</span> reduction from state 6 we avoid some redundant graph searching, but for this parse, we also incorrectly reject a string in the language of Grammar 5.2.</p>
<p>Although it is not generally possible to remove <span class="math notranslate nohighlight">\(\epsilon\)</span> reductions from the parse table it is possible to identify points in the GSS construction when their application is redundant. The next section presents a general parsing algorithm, based on Algorithm 1e, that incorporates this allowing right nullable grammars to be parsed more efficiently. In Section 5.6 we discuss an approach that eliminates redundant reductions without compromising the correctness of the underlying parser for RN parse tables of LR grammars.</p>
</section>
<section id="the-rnglr-recognition-algorithm">
<h2>5.4 The RNGLR recognition algorithm<a class="headerlink" href="#the-rnglr-recognition-algorithm" title="Permalink to this heading">¶</a></h2>
<p>This section presents the Right Nulled GLR (RNGLR) recogniser which correctly parses all context-free grammars with the use of an RN parse table [15]. A description of the algorithm is given and a discussion highlighting the differences between RNGLR and Algorithm 1e is undertaken.</p>
<section id="rnglr-recogniser">
<h3>RNGLR recogniser<a class="headerlink" href="#rnglr-recogniser" title="Permalink to this heading">¶</a></h3>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080452110.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080452232.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080453165.png" /></p>
<p>The RNGLR algorithm looks very similar to Algorithm 1e but includes some subtle changes that make a big difference to the efficiency of the algorithm. One of the major differences in the appearance between the two algorithms is the lack of the Actor function in RNGLR. When a new node is created in the GSS by Algorithm 1e the Actor is used to perform the parse table lookup to retrieve the actions associated to the state that labels the new node. If a reduction of length <span class="math notranslate nohighlight">\(&gt;0\)</span> is found then the Actor finds the new node’s successors and adds the triple <span class="math notranslate nohighlight">\(\langle v,x,p\rangle\)</span> to the set <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>. The reason for using the successors of a new node is to ensure that when a reduction is done, it is only performed down the same path at most once. However, the successor nodes are known when a new node is created by the Shifter or Reducer and by waiting to process a new node in the Actor, the information is lost and the algorithm needs to perform an unnecessary search for every node created. In comparison the RNGLR algorithm adds reductions to the set <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> when a new edge is created between two nodes. This results in the RNGLR algorithm performing one edge traversal less than Algorithm 1e for every reduction added to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> when a new node is created.</p>
<p>The RNGLR algorithm is optimised to exploit the features of an RN parse table. It takes advantage of the RN reductions to parse grammars with right nullable rules more efficiently than Algorithm 1e. Although one might expect the algorithm to perform more reductions and hence more edge visits as a result of the increased number of conflicts in the RN table, it turns out that fewer edge visits are performed because as we now discuss, reductions are not performed in certain cases.</p>
<p>If <span class="math notranslate nohighlight">\(\beta\stackrel{{*}}{{\Rightarrow}}\epsilon\)</span> the RN parse table causes Algorithm 1e to do a reduction for a rule <span class="math notranslate nohighlight">\(A::=\alpha\cdot\beta\)</span> after it shifts the final symbol in <span class="math notranslate nohighlight">\(\alpha\)</span>. So <span class="math notranslate nohighlight">\(|\beta|\)</span> fewer edge visits are done for the reduction than for the rule <span class="math notranslate nohighlight">\(A::=\alpha\beta\cdot\)</span>. However, the RN table also includes <span class="math notranslate nohighlight">\(|\beta|\)</span> extra reductions, one for each nullable non-terminal in <span class="math notranslate nohighlight">\(\beta\)</span>, which Algorithm 1e also performs, more than eliminating the initial saving that was made. To prevent this from happening the RNGLR algorithm only adds new reductions to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> if the length of the reduction that results in the new reduction path being created is greater than <span class="math notranslate nohighlight">\(0\)</span>. The reasoning behind this is that if a new edge is created as part of a reduction of length <span class="math notranslate nohighlight">\(0\)</span>, all reductions of length greater than <span class="math notranslate nohighlight">\(0\)</span> will have already been done by a previous RN reduction. For proofs of correctness of this approach see [11].</p>
<p>For example, consider the RNGLR parse of the string <span class="math notranslate nohighlight">\(aab\)</span>, with Grammar 4.2 and the RN parse table shown in Table 5.2. We begin by creating the state node <span class="math notranslate nohighlight">\(v_{0}\)</span>, labelled by the start state <span class="math notranslate nohighlight">\(0\)</span>, in <span class="math notranslate nohighlight">\(U_{0}\)</span>. Since the only action in <span class="math notranslate nohighlight">\(\mathcal{T}(0,a)\)</span> is a shift to state <span class="math notranslate nohighlight">\(3\)</span>, we add <span class="math notranslate nohighlight">\((v_{0},3)\)</span> to <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span> and proceed to execute the Shifter. We create the new node <span class="math notranslate nohighlight">\(v_{1}\)</span>, labelled <span class="math notranslate nohighlight">\(3\)</span>, in <span class="math notranslate nohighlight">\(U_{1}\)</span> and lookup its associated actions in <span class="math notranslate nohighlight">\(\mathcal{T}(3,a)\)</span>. There is only a shift action to state <span class="math notranslate nohighlight">\(3\)</span>, so <span class="math notranslate nohighlight">\((v_{1},3)\)</span> is first added to <span class="math notranslate nohighlight">\(\mathcal{Q}^{\prime}\)</span> and then to <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080453581.png" />
We continue the parse by shifting the next two input symbols and creating the nodes <span class="math notranslate nohighlight">\(v_{2}\)</span> and <span class="math notranslate nohighlight">\(v_{3}\)</span> in <span class="math notranslate nohighlight">\(U_{2}\)</span> and <span class="math notranslate nohighlight">\(U_{3}\)</span> respectively. Upon the creation of <span class="math notranslate nohighlight">\(v_{3}\)</span> in the Shifterwe encounter a reduction <span class="math notranslate nohighlight">\(r(S,1)\)</span> in <span class="math notranslate nohighlight">\(\mathcal{T}(2,\$)\)</span> and add <span class="math notranslate nohighlight">\((v_{2},S,1)\)</span> to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080454505.png" /></p>
<p>Processing <span class="math notranslate nohighlight">\((v_{2},S,1)\)</span> in the Reducer we find the shift to state <span class="math notranslate nohighlight">\(4\)</span> in <span class="math notranslate nohighlight">\(\mathcal{T}(3,\$)\)</span>. Since there is no node labelled <span class="math notranslate nohighlight">\(4\)</span> in <span class="math notranslate nohighlight">\(U_{3}\)</span> we create <span class="math notranslate nohighlight">\(v_{4}\)</span> and a new edge from <span class="math notranslate nohighlight">\(v_{4}\)</span> to <span class="math notranslate nohighlight">\(v_{2}\)</span>. There is a reduce/reduce conflict in <span class="math notranslate nohighlight">\(\mathcal{T}(4,\$)\)</span> so we add <span class="math notranslate nohighlight">\((v_{4},B,0)\)</span> and <span class="math notranslate nohighlight">\((v_{2},S,2)\)</span> to the set <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080454479.png" /></p>
<p>When <span class="math notranslate nohighlight">\((v_{4},B,0)\)</span> is processed by the Reducer the new node <span class="math notranslate nohighlight">\(v_{5}\)</span>, labelled <span class="math notranslate nohighlight">\(5\)</span>, and the edge from <span class="math notranslate nohighlight">\(v_{5}\)</span> to <span class="math notranslate nohighlight">\(v_{4}\)</span> are created. Although there is a reduction in <span class="math notranslate nohighlight">\(\mathcal{T}(5,\$)\)</span> it is not added to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>. This is a feature of the RNGLR algorithm to prevent reductions that are redundant from being performed. Since the right-nullable reduction <span class="math notranslate nohighlight">\(r(S,2)\)</span> was added to <span class="math notranslate nohighlight">\(\mathcal{T}(4,\$)\)</span> the reduction that would normally be performed after all nullable non-terminals have been reduced was performed early.</p>
<p>We continue the parse by processing <span class="math notranslate nohighlight">\((v_{2},S,2)\)</span>, and tracing back a path of length one from <span class="math notranslate nohighlight">\(v_{2}\)</span> to <span class="math notranslate nohighlight">\(v_{1}\)</span>. Since there is already node labelled <span class="math notranslate nohighlight">\(4\)</span> in <span class="math notranslate nohighlight">\(U_{3}\)</span> the new edge between <span class="math notranslate nohighlight">\(v_{4}\)</span> and <span class="math notranslate nohighlight">\(v_{1}\)</span> is created. The new edge creates a new reduction path that the reduction <span class="math notranslate nohighlight">\(r(S,2)\)</span> in state <span class="math notranslate nohighlight">\(4\)</span> can be applied down so <span class="math notranslate nohighlight">\((v_{1},S,2)\)</span> is added to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080454042.png" /></p>
<p>Processing <span class="math notranslate nohighlight">\((v_{1},S,2)\)</span> we trace back a path of length one from <span class="math notranslate nohighlight">\(v_{1}\)</span> to <span class="math notranslate nohighlight">\(v_{0}\)</span> which results in the new state <span class="math notranslate nohighlight">\(v_{6}\)</span> labelled <span class="math notranslate nohighlight">\(1\)</span> and the edge <span class="math notranslate nohighlight">\((v_{6},v_{0})\)</span> being added to the GSS. All of the sets are now empty and since <span class="math notranslate nohighlight">\(U_{3}\)</span> contains a state labelled by the DFA’s accept state, the parse succeeds.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080454091.png" /></p>
</section>
</section>
<section id="the-rnglr-parsing-algorithm">
<h2>5.5 The RNGLR parsing algorithm<a class="headerlink" href="#the-rnglr-parsing-algorithm" title="Permalink to this heading">¶</a></h2>
<p>The parser version of the RNGLR algorithm is a straightforward extension of the recogniser described in the previous section. Chapter 4 presented both Tomita’s and Rekers’ approach to the construction of the SPPF. This section provides a brief overview of the main points in that chapter and a discussion of the approach taken by the RNGLR parser.</p>
<p>There are three conflicting goals associated with the construction of an SPPF: building a compact structure; minimising the amount of time taken to build the structure; and ensuring that for ambiguous sentences one derivation tree can be efficiently extracted. Tomita focused on the efficiency of the construction, only implementing a minimal amount of sharing and packing, thereby increasing the space required for the SPPF. Rekers extended Tomita’s approach by increasing the amount of SPPF node sharing at the cost of introducing more searching to the algorithm. The RNGLR parser implements Rekers’ approach in conjunction with several techniques designed to reduce the amount of searching required by the algorithm.</p>
<p>Rekers splits the SPPF nodes into two categories: nodes for the non-terminals called rule nodes and nodes for the terminals called symbol nodes. In order to achieve the sharing in the SPPF the rule and symbol nodes created for the current level are stored in two distinct sets. Before either type of node is created, the required set is searched for an existing node that covers the same part of the input. To do this without having to inspect all the subtrees of a node, the start and end positions of the input that the particular node derives are also stored with the node. A leaf node created for the input symbol at position <span class="math notranslate nohighlight">\(i\)</span>, is labelled <span class="math notranslate nohighlight">\((a,i,i)\)</span>. A rule node is labelled in a similar way, but takes the first value from its leftmost child and the second value from its rightmost child. So for the input <span class="math notranslate nohighlight">\(a_{1}\ldots a_{d}\)</span>, a rule node labelled <span class="math notranslate nohighlight">\((X,j,i)\)</span> means that <span class="math notranslate nohighlight">\(X\stackrel{{*}}{{\Rightarrow}}a_{j}\ldots a_{i}\)</span>. If <span class="math notranslate nohighlight">\(X\stackrel{{*}}{{\Rightarrow}}\epsilon\)</span> then <span class="math notranslate nohighlight">\(i,j=0\)</span>.</p>
<p>The RNGLR parser implements Rekers’ approach for the construction of the SPPF as opposed to Tomita’s because of the more compact SPPF built. Although both the RNGLR and Rekers’ algorithm build the same SPPF they do so in a slightly different way. Instead of storing the SPPF nodes for the terminals and non-terminals separately, the RNGLR algorithm uses one set called <span class="math notranslate nohighlight">\(\mathcal{N}\)</span> which is reset after each iteration in Parser. In addition to this, because we always know the current level being constructed, only the start position of the string derived is included in an SPPF node. So instead of labeling an SPPF node with a triple <span class="math notranslate nohighlight">\((X,j,i)\)</span>, it is labelled with the pair <span class="math notranslate nohighlight">\((X,j)\)</span> and stored in <span class="math notranslate nohighlight">\(\mathcal{N}\)</span>.</p>
<p>The RNGLR algorithm only works when used in conjunction with an RN parse table. When a grammar containing right nullable rules is parsed, the right nullable reductions will be done without tracing back over the edges containing the SPPF nodes for the nullable non-terminals. As a result it is necessary to build the SPPF trees forthe nullable non-terminals, and the rightmost nullable strings of non-terminals of a right night nullable rule, before the parse is begun. These nullable trees are called <span class="math notranslate nohighlight">\(\epsilon\)</span>-SPPF trees and since they are constant for a given grammar, they can be constructed when the parser is built and included in the RN parse table. Instead of storing reductions as the tuple <span class="math notranslate nohighlight">\(r(X,m)\)</span>, the RN parse table stores the triple <span class="math notranslate nohighlight">\(r(X,m,f)\)</span>, where <span class="math notranslate nohighlight">\(X\)</span> is a non-terminal, <span class="math notranslate nohighlight">\(m\)</span> is the length of the reduction and <span class="math notranslate nohighlight">\(f\)</span> is an index into a function <span class="math notranslate nohighlight">\(I\)</span> that returns the root of the associated <span class="math notranslate nohighlight">\(\epsilon\)</span>-SPPF tree. If no <span class="math notranslate nohighlight">\(\epsilon\)</span>-SPPF tree is associated with such a reduction then <span class="math notranslate nohighlight">\(f=0\)</span>.</p>
<p>If all the <span class="math notranslate nohighlight">\(\epsilon\)</span>-SPPF trees are created for all the nullable reductions, the final SPPF will not be as compact as it could be. So the <span class="math notranslate nohighlight">\(\epsilon\)</span>-SPPF’s are only constructed for nullable non-terminals and nullable strings <span class="math notranslate nohighlight">\(\gamma\)</span>, such that <span class="math notranslate nohighlight">\(|\gamma|&gt;1\)</span> and there is a grammar rule of the form <span class="math notranslate nohighlight">\(A::=\alpha\gamma\)</span>, where <span class="math notranslate nohighlight">\(\alpha\neq\epsilon\)</span>. Nullable strings like <span class="math notranslate nohighlight">\(\gamma\)</span> are called the <em>required nullable parts</em>. For rules of the form <span class="math notranslate nohighlight">\(A::=\gamma\)</span> where <span class="math notranslate nohighlight">\(\gamma\stackrel{{*}}{{\Rightarrow}}\epsilon\)</span> the <span class="math notranslate nohighlight">\(\epsilon\)</span>-SPPF for <span class="math notranslate nohighlight">\(A\)</span> is used instead.</p>
<p>In order to create the index to the <span class="math notranslate nohighlight">\(\epsilon\)</span>-SPPF trees it is necessary to go through the grammar and, starting at one, index the required nullable parts and the non-terminals that derive <span class="math notranslate nohighlight">\(\epsilon\)</span>. Before constructing the <span class="math notranslate nohighlight">\(\epsilon\)</span>-SPPF trees, create the node <span class="math notranslate nohighlight">\(u_{0}\)</span> labelled <span class="math notranslate nohighlight">\(\epsilon\)</span>. Then create the <span class="math notranslate nohighlight">\(\epsilon\)</span>-SPPF trees with the root node <span class="math notranslate nohighlight">\(u_{I(\omega)}\)</span>, labelled <span class="math notranslate nohighlight">\(\omega\)</span>, for the nullable non-terminals or required nullable parts <span class="math notranslate nohighlight">\(\omega\)</span>. In the RN parse table for a reduction <span class="math notranslate nohighlight">\((A::=\alpha\cdot\gamma,a)\)</span> write <span class="math notranslate nohighlight">\(r(A,m,f)\)</span>, where <span class="math notranslate nohighlight">\(|\alpha|=m\)</span> and <span class="math notranslate nohighlight">\(f=I(\gamma)\)</span> if <span class="math notranslate nohighlight">\(m\neq 0\)</span> and <span class="math notranslate nohighlight">\(f=I(A)\)</span> if <span class="math notranslate nohighlight">\(m=0\)</span>.</p>
<p>The elements added to the sets <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{Q}^{\prime}\)</span> are the same as those used by the RNGLR recogniser, but the elements added to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> contain more information. When a new edge is added between two nodes <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(w\)</span>, any applicable reductions from <span class="math notranslate nohighlight">\(v\)</span> are added to the set <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>. For a reduction of the form <span class="math notranslate nohighlight">\(r(X,m,f)\)</span>, where <span class="math notranslate nohighlight">\(m&gt;0\)</span>, we add <span class="math notranslate nohighlight">\((w,X,m,f,z)\)</span> to the set <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>. The first three elements, <span class="math notranslate nohighlight">\(w,X,m\)</span> are the same as those used in the recogniser (state node, non-terminal, length of reduction). If the reduction is an RN-reduction of the form <span class="math notranslate nohighlight">\((X::=\alpha\cdot\beta)\)</span> then <span class="math notranslate nohighlight">\(f\)</span> is the index into the function <span class="math notranslate nohighlight">\(I\)</span> which stores the root node of the <span class="math notranslate nohighlight">\(\epsilon\)</span>-SPPF for <span class="math notranslate nohighlight">\(\beta\)</span> and <span class="math notranslate nohighlight">\(z\)</span> is the SPPF node that labels the edge between <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(w\)</span>. If the length of the reduction is zero (<span class="math notranslate nohighlight">\(m=0\)</span>) then <span class="math notranslate nohighlight">\(f\)</span> is the index into <span class="math notranslate nohighlight">\(I\)</span> for the root of the <span class="math notranslate nohighlight">\(\epsilon\)</span>-SPPF of <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(z\)</span> is <span class="math notranslate nohighlight">\(\epsilon\)</span>, since the edge between <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(w\)</span> is not traversed.</p>
<p>For example, consider Grammar 5.3. The nullable non-terminals are <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(C\)</span>, and the required nullable parts are <span class="math notranslate nohighlight">\(BBC\)</span> and <span class="math notranslate nohighlight">\(BC\)</span>. We define <span class="math notranslate nohighlight">\(I(B)=1\)</span>, <span class="math notranslate nohighlight">\(I(C)=2\)</span>, <span class="math notranslate nohighlight">\(I(BC)=3\)</span> and <span class="math notranslate nohighlight">\(I(BBC)=4\)</span>. The associated <span class="math notranslate nohighlight">\(\epsilon\)</span>-SPPF is shown in Figure 5.5.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080601149.png" /></p>
<p><img alt="" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080455234.png" />
Before presenting the formal specification of the RNGLR parser we demonstrate how the GSS and SPPF are constructed for the parse of the string <span class="math notranslate nohighlight">\(ab\)</span> in Grammar 5.3. The associated LR(1) DFA and RN parse table are shown in Figure 5.6 and Table 5.4.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080455590.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080456676.png" />
We create <span class="math notranslate nohighlight">\(v_{0}\)</span>, labelled by the start state of the DFA, and add it to <span class="math notranslate nohighlight">\(U_{0}\)</span>. Since the only applicable action in <span class="math notranslate nohighlight">\(\mathcal{T}(0,a)\)</span> is a shift to state 2, we add <span class="math notranslate nohighlight">\((v_{0},2)\)</span> to <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span>. The Shifter removes <span class="math notranslate nohighlight">\((v_{0},2)\)</span> from <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span> and creates a new SPPF node, <span class="math notranslate nohighlight">\(w_{1}\)</span>, labelled <span class="math notranslate nohighlight">\((a,1)\)</span>. Then since no node labelled 2 exists in the next level, <span class="math notranslate nohighlight">\(v_{1}\)</span> is created and added to <span class="math notranslate nohighlight">\(U_{1}\)</span>, with an edge back to <span class="math notranslate nohighlight">\(v_{0}\)</span> labelled by <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(w_{1}\)</span>. There is a shift/reduce conflict in <span class="math notranslate nohighlight">\(\mathcal{T}(2,b)\)</span>: a shift to state <span class="math notranslate nohighlight">\(4\)</span> and a reduction <span class="math notranslate nohighlight">\(r(B,0,1)\)</span>. We add <span class="math notranslate nohighlight">\((v_{1},4)\)</span> to <span class="math notranslate nohighlight">\(\mathcal{Q}^{\prime}\)</span> and <span class="math notranslate nohighlight">\((v_{1},B,0,1,\epsilon)\)</span> to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>.</p>
<p>This completes the construction of the first level and the initialisation of <span class="math notranslate nohighlight">\(U_{1}\)</span>. The GSS and SPPF constructed up to this point are shown below.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080457696.png" />
Next we process the reduction <span class="math notranslate nohighlight">\((v_{1},B,0,1,\epsilon)\)</span> in the Reducer. It is a nullable reduction so we do not trace back a path in the GSS, but we do create the new node, <span class="math notranslate nohighlight">\(v_{2}\)</span>, labelled <span class="math notranslate nohighlight">\(3\)</span>, with an edge back to <span class="math notranslate nohighlight">\(v_{1}\)</span>. We label the edge by the non-terminal of the reduction, <span class="math notranslate nohighlight">\(B\)</span>, and the root of the <span class="math notranslate nohighlight">\(\epsilon\)</span>-SPPF tree for <span class="math notranslate nohighlight">\(B\)</span>. Since there is a shift action in <span class="math notranslate nohighlight">\(\mathcal{T}(3,b)\)</span> we add <span class="math notranslate nohighlight">\((v_{2},6)\)</span> to <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080458391.png" /></p>
<p>Processing the two queued shift actions in <span class="math notranslate nohighlight">\(\mathcal{Q}\)</span> results in the construction of the SPPF node <span class="math notranslate nohighlight">\(w_{2}\)</span> and the two new GSS nodes <span class="math notranslate nohighlight">\(v_{3}\)</span> and <span class="math notranslate nohighlight">\(v_{4}\)</span>. There is a reduction <span class="math notranslate nohighlight">\(r(B,1,0)\)</span> from both nodes, so we add <span class="math notranslate nohighlight">\((v_{1},B,1,0,w_{2})\)</span> and <span class="math notranslate nohighlight">\((v_{2},B,1,0,w_{2})\)</span> to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080458281.png" /></p>
<p>Processing the first of these reductions, we create the new SPPF node, <span class="math notranslate nohighlight">\(w_{3}\)</span>, labelled <span class="math notranslate nohighlight">\((B,1)\)</span>, add it to the set <span class="math notranslate nohighlight">\(\mathcal{N}\)</span> and then use it to label the edge between the new GSS node, <span class="math notranslate nohighlight">\(v_{5}\)</span>, and <span class="math notranslate nohighlight">\(v_{1}\)</span>. We make the SPPF node, <span class="math notranslate nohighlight">\(w_{2}\)</span>, that labelled the edge between <span class="math notranslate nohighlight">\(v_{3}\)</span> and <span class="math notranslate nohighlight">\(v_{1}\)</span> the child of <span class="math notranslate nohighlight">\(w_{3}\)</span>. Since there is a reduce/reduce conflict, <span class="math notranslate nohighlight">\(r(B,0,1)\)</span> and <span class="math notranslate nohighlight">\(r(S,2,3)\)</span>, in <span class="math notranslate nohighlight">\(\mathcal{T}(3,\$)\)</span> we add <span class="math notranslate nohighlight">\((v_{5},B,0,1,\epsilon)\)</span> and <span class="math notranslate nohighlight">\((v_{1},S,2,3,w_{3})\)</span> to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>.
When we process the queued reduction <span class="math notranslate nohighlight">\((v_{2},B,1,0,w_{2})\)</span> we create the new GSS node <span class="math notranslate nohighlight">\(v_{6}\)</span> labelled <span class="math notranslate nohighlight">\(5\)</span> and an edge to <span class="math notranslate nohighlight">\(v_{2}\)</span>. However, because there has already been the SPPF node, <span class="math notranslate nohighlight">\(w_{3}\)</span>, labelled <span class="math notranslate nohighlight">\((B,1)\)</span> created in the current step of the algorithm (and stored in the set <span class="math notranslate nohighlight">\(\mathcal{N}\)</span>) we re-use it to label the edge between <span class="math notranslate nohighlight">\(v_{6}\)</span> and <span class="math notranslate nohighlight">\(v_{2}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080516265.png" /></p>
<p>At this point <span class="math notranslate nohighlight">\(\mathcal{R}=\{(v_{5},B,0,1,\epsilon),(v_{1},S,2,3,w_{3}),(v_{6},C,0,2,\epsilon),(v_ {2},S,3,2,w_{3})\}\)</span>. We remove and process the first of these reductions which results in the new edge, labelled <span class="math notranslate nohighlight">\((B,u_{1})\)</span>, being added between <span class="math notranslate nohighlight">\(v_{6}\)</span> and <span class="math notranslate nohighlight">\(v_{5}\)</span>. Although the new edge has introduced a new reduction path from <span class="math notranslate nohighlight">\(v_{6}\)</span>, we do not add anything to the set <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> because the reduction performed was of length zero.</p>
<p>Next we process <span class="math notranslate nohighlight">\((v_{1},S,2,3,w_{3})\)</span>. We trace back a path of length one from <span class="math notranslate nohighlight">\(v_{1}\)</span> to <span class="math notranslate nohighlight">\(v_{0}\)</span>, collecting the SPPF node, <span class="math notranslate nohighlight">\(w_{1}\)</span>, that labels the edge traversed. We create the new GSS node, <span class="math notranslate nohighlight">\(v_{7}\)</span>, labelled <span class="math notranslate nohighlight">\(1\)</span> and an edge between <span class="math notranslate nohighlight">\(v_{7}\)</span> and <span class="math notranslate nohighlight">\(v_{0}\)</span>. We create the new SPPF node, <span class="math notranslate nohighlight">\(w_{4}\)</span>, labelled <span class="math notranslate nohighlight">\((S,0)\)</span> with edges pointing to the nodes <span class="math notranslate nohighlight">\(w_{1},w_{3}\)</span> and <span class="math notranslate nohighlight">\(u_{3}\)</span> and use it to label the edge between <span class="math notranslate nohighlight">\(v_{7}\)</span> and <span class="math notranslate nohighlight">\(v_{0}\)</span> in the GSS. We also add <span class="math notranslate nohighlight">\(w_{4}\)</span> into the set <span class="math notranslate nohighlight">\(\mathcal{N}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080516485.png" /></p>
<p>Processing the reduction encoded by <span class="math notranslate nohighlight">\((v_{6},C,0,2,\epsilon)\)</span> we create the new GSS node <span class="math notranslate nohighlight">\(v_{8}\)</span>, labelled <span class="math notranslate nohighlight">\(7\)</span>, and an edge from <span class="math notranslate nohighlight">\(v_{8}\)</span> to <span class="math notranslate nohighlight">\(v_{6}\)</span>. Since the reduction is nullable, we label the new edge by the <span class="math notranslate nohighlight">\(\epsilon\)</span>-SPPF node <span class="math notranslate nohighlight">\(u_{2}\)</span> and do not add any other reductions to <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>.</p>
<p>We then process the final reduction in <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>, <span class="math notranslate nohighlight">\((v_{2},S,3,2,w_{3})\)</span>. We trace back a path of length two from <span class="math notranslate nohighlight">\(v_{2}\)</span> to <span class="math notranslate nohighlight">\(v_{0}\)</span> and collect the SPPF nodes <span class="math notranslate nohighlight">\(u_{1}\)</span> and <span class="math notranslate nohighlight">\(w_{1}\)</span> that label the traversed edges. We search the set <span class="math notranslate nohighlight">\(\mathcal{N}\)</span> for a node labelled <span class="math notranslate nohighlight">\((S,0)\)</span> and find <span class="math notranslate nohighlight">\(w_{4}\)</span>. Since it does not have a sequence of children <span class="math notranslate nohighlight">\([w_{1},u_{1},w_{3},u_{2}]\)</span> we create two new packing nodes below <span class="math notranslate nohighlight">\(w_{4}\)</span> and add the existing children of <span class="math notranslate nohighlight">\(w_{4}\)</span> to one and the new sequence to the other.</p>
<p>At this point all the input string has been parsed and no other actions remain to be processed. Since the accept state of the DFA labels <span class="math notranslate nohighlight">\(v_{7}\)</span>, the parse is successful and the root of the SPPF is the node that labels the edge between <span class="math notranslate nohighlight">\(v_{7}\)</span> and <span class="math notranslate nohighlight">\(v_{0}\)</span>, <span class="math notranslate nohighlight">\(w_{4}\)</span>. The final GSS and SPPF constructed during the parse are shown in Figure 5.7.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080516341.png" /></p>
<section id="rnglr-parser">
<h3>RNGLR parser<a class="headerlink" href="#rnglr-parser" title="Permalink to this heading">¶</a></h3>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080517301.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080518767.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080519805.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080519722.png" /></p>
</section>
</section>
<section id="resolvability">
<h2>5.6 Resolvability<a class="headerlink" href="#resolvability" title="Permalink to this heading">¶</a></h2>
<p>In Section 5.3 we discussed the effect of the extra non-determinism created as a result of the nullable reductions added to the RN parse table. In this section we present an approach, first described in [10], of removing redundant nullable reductions from the RN parse table of LR grammars with right nullable rules. In certain cases this new <em>resolved</em> parse table can be used by the standard LR parsing algorithm, to parse certain strings with less stack activity. It has been shown in [10] that for an LR grammar it is possible to remove all reduce/reduce conflicts from an RN parse table so that the standard LR parsing algorithm can be used to parse sentences with less stack activity.</p>
<p>In order to remove reductions from a state <span class="math notranslate nohighlight">\(k\)</span> without breaking the parser, it is necessary for <span class="math notranslate nohighlight">\(k\)</span> and a lookahead <span class="math notranslate nohighlight">\(a\)</span> to conform to the following two properties.</p>
<ol class="arabic simple">
<li><p>For each <span class="math notranslate nohighlight">\(a\in\mathbf{T}\cup\{\$\}\)</span> there is at most one item <span class="math notranslate nohighlight">\((X::=\tau\cdot\sigma,a)\in k\)</span>, such that <span class="math notranslate nohighlight">\(\tau\neq\epsilon\)</span> and <span class="math notranslate nohighlight">\(\sigma\stackrel{{*}}{{\Rightarrow}}\epsilon\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\((X::=\tau\cdot\sigma,a)\in k\)</span>, where <span class="math notranslate nohighlight">\(\sigma\stackrel{{*}}{{\Rightarrow}}\epsilon\)</span>, and <span class="math notranslate nohighlight">\((W::=\alpha\cdot\beta,g)\in k\)</span>, where  <span class="math notranslate nohighlight">\(a\in\text{FIRST}(\beta)\)</span>, then <span class="math notranslate nohighlight">\(\tau=\epsilon\)</span> and any derivation <span class="math notranslate nohighlight">\(\beta\stackrel{{*}}{{\Rightarrow}}au\)</span> includes a step <span class="math notranslate nohighlight">\(Xau\stackrel{{*}}{{\Rightarrow}}\sigma au\)</span>.</p></li>
</ol>
<p>Such states are called <em>a-resolvable</em>. The two properties above work on the principle that a state <span class="math notranslate nohighlight">\(k\)</span> with an item of the form <span class="math notranslate nohighlight">\((X::=\tau\cdot\sigma,a)\)</span>, where <span class="math notranslate nohighlight">\(\tau\neq\epsilon\)</span> and <span class="math notranslate nohighlight">\(\sigma\stackrel{{*}}{{\Rightarrow}}\epsilon\)</span> can have all but one of its reductions, for the lookahead <span class="math notranslate nohighlight">\(a\)</span>, removed as long as property 2 is not broken. This is because we can define the order in which rules are added toa DFA state and hence guarantee that the reduction for the rule <span class="math notranslate nohighlight">\(X::=\tau\sigma\)</span> must take place before any other action can happen.</p>
<p>The reduction that is not removed from an a-resolvable state <span class="math notranslate nohighlight">\(k\)</span> is known as the <em>base reduction</em> of <span class="math notranslate nohighlight">\(k\)</span> for lookahead <span class="math notranslate nohighlight">\(a\)</span>. To formally define a base reduction it is necessary to first define a function to calculate the order in which items are added to a DFA state.</p>
<p>Definition 5.1: <em>Let <span class="math notranslate nohighlight">\(k\)</span> be a DFA state and let <span class="math notranslate nohighlight">\((X::=\tau\cdot\sigma,a)\)</span> be an item in <span class="math notranslate nohighlight">\(k\)</span>. If <span class="math notranslate nohighlight">\(\tau=\epsilon\)</span> then we define <span class="math notranslate nohighlight">\(level_{k}(X::=\tau\cdot\sigma,a)=0\)</span>. We also define <span class="math notranslate nohighlight">\(level_{0}(S^{\prime}::=\cdot S,\$)=0\)</span>. For <span class="math notranslate nohighlight">\(X\neq S^{\prime}\)</span> and <span class="math notranslate nohighlight">\(\tau=\epsilon\)</span> we let</em></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080602073.png" /></p>
<p><em>and then define <span class="math notranslate nohighlight">\(level_{k}(X::=\cdot\sigma,a)=(r+1)\)</span>. [SJ03a]</em></p>
<p>Definition 5.2: <em>Let <span class="math notranslate nohighlight">\(\Gamma\)</span> be any context-free grammar and let <span class="math notranslate nohighlight">\(k\)</span> be an <span class="math notranslate nohighlight">\(a\)</span>-resolvable state in the DFA for <span class="math notranslate nohighlight">\(\Gamma\)</span>. An item <span class="math notranslate nohighlight">\((X::=\tau\cdot\sigma,a)\in k\)</span> is a base reduction on <span class="math notranslate nohighlight">\(a\)</span> in <span class="math notranslate nohighlight">\(k\)</span> if, for all other items <span class="math notranslate nohighlight">\((Y::=\gamma\cdot\delta,a)\in k\)</span> such that <span class="math notranslate nohighlight">\(\delta\stackrel{{*}}{{\Rightarrow}}\epsilon,level_{k}(X::=\tau \cdot\sigma,a)\leq level_{k}(Y::=\gamma\cdot\delta,a)\)</span>.[10]</em></p>
<p>Table 5.8 shows how the resolved RN parse table of the LR(1) grammar 5.4 can be used by the standard LR(1) parsing algorithm, to parse a sentence using less stack activity than when the LR(1) table is used.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080521897.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080521865.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080522680.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080522084.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080522273.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080522639.png" /></p>
</section>
<section id="summary">
<h2>5.7 Summary<a class="headerlink" href="#summary" title="Permalink to this heading">¶</a></h2>
<p>This chapter has presented Algorithm 1e - a straightforward extension of Tomita’s Algorithm 1 that can deal with hidden-left recursion, but which fails to parse grammars containing hidden-right recursion. A modification to the standard LR(1) parse table was introduced which causes Algorithm 1e to correctly parse all context-free grammars. Tables containing this modification are called RN tables. The RNGLR recognition algorithm that parses all context-free grammars with the use of an RN parse table was described and its operation demonstrated with various examples. The RNGLR parser that constructs an SPPF in the style of Rekers, but which employs less searching, was also presented.</p>
<p>Chapter 10 presents the experimental results that abstract the performance of Algorithm 1e, Algorithm 1e mod, and the RNGLR algorithm for grammars which trigger worst case behaviour and several programming language grammars and strings.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="4%20Generalised%20LR%20parsing.html" class="btn btn-neutral float-left" title="4. Generalised LR parsing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="6%20Binary%20Right%20Nulled%20Generalised%20LR%20parsing.html" class="btn btn-neutral float-right" title="6.Binary Right Nulled Generalised LR parsing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, xrtero.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>