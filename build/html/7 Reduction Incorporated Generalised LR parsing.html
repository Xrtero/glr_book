<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>7.Reduction Incorporated Generalised LR parsing &mdash; Generalised LR parsing algorithms  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="canonical" href="https://www.xrtero.com/book/glr/7 Reduction Incorporated Generalised LR parsing.html" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=b3ba4146"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="8 Other approaches to generalised parsing" href="8%20Other%20approaches%20to%20generalised%20parsing.html" />
    <link rel="prev" title="6.Binary Right Nulled Generalised LR parsing" href="6%20Binary%20Right%20Nulled%20Generalised%20LR%20parsing.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Generalised LR parsing algorithms
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1%20Introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="2%20%20Recognition%20and%20parsing.html">2. Recognition and parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="3%20The%20development%20of%20generalised%20parsing.html">3. The development of generalised parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="4%20Generalised%20LR%20parsing.html">4. Generalised LR parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="5%20Right%20Nulled%20Generalised%20LR%20parsing.html">5. Right Nulled Generalised LR parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="6%20Binary%20Right%20Nulled%20Generalised%20LR%20parsing.html">6.Binary Right Nulled Generalised LR parsing</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">7.Reduction Incorporated Generalised LR parsing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-role-of-the-stack-in-bottom-up-parsers">7.1 The role of the stack in bottom-up parsers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#constructing-the-intermediate-reduction-incorporated-automata">7.2 Constructing the Intermediate Reduction Incorporated Automata</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#iria-construction-algorithm">IRIA construction algorithm</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#reducing-non-determinism-in-the-iria">7.3 Reducing non-determinism in the IRIA</a></li>
<li class="toctree-l2"><a class="reference internal" href="#regular-recognition">7.4 Regular recognition</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#recursion-call-automata">7.4.1 Recursion call automata</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parse-table-representation-of-rca">7.4.2 Parse table representation of RCA</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#generalised-regular-recognition">7.5 Generalised regular recognition</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example-right-and-hidden-left-recursion">Example - right and hidden-left recursion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-further-issues-surrounding-hidden-left-recursion">Example - further issues surrounding hidden-left recursion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-ensuring-all-pop-actions-are-done">Example - ensuring all pop actions are done</a></li>
<li class="toctree-l3"><a class="reference internal" href="#riglr-recogniser">RIGLR recogniser</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#reducing-the-non-determinism-in-the-rca">7.6 Reducing the non-determinism in the RCA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#reducing-the-number-of-processes-in-each-u-i">Reducing the number of processes in each <span class="math notranslate nohighlight">\(U_{i}\)</span></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#generalised-regular-parsing">7.8 Generalised regular parsing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#constructing-derivation-trees">7.8.1 Constructing derivation trees</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constructing-an-sppf">7.8.2 Constructing an SPPF</a></li>
<li class="toctree-l3"><a class="reference internal" href="#riglr-parser">RIGLR parser</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#summary">7.9 Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="8%20Other%20approaches%20to%20generalised%20parsing.html">8 Other approaches to generalised parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="9%20Some%20generalised%20parser%20generators.html">9. Some generalised parser generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="10%20Experimental%20investigation.html">10. Experimental investigation</a></li>
<li class="toctree-l1"><a class="reference internal" href="11%20Concluding%20remarks.html">11. Concluding remarks</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Generalised LR parsing algorithms</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">7.Reduction Incorporated Generalised LR parsing</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/7 Reduction Incorporated Generalised LR parsing.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="reduction-incorporated-generalised-lr-parsing">
<h1>7.Reduction Incorporated Generalised LR parsing<a class="headerlink" href="#reduction-incorporated-generalised-lr-parsing" title="Permalink to this heading">¶</a></h1>
<p>The most efficient general parsing algorithm to date achieves <span class="math notranslate nohighlight">\(O(n^{2.376})\)</span> worst case time complexity. Unfortunately, as already discussed in the previous chapter, the high constants of proportionality associated with this technique make it impractical for all but the longest strings.</p>
<p>This thesis focuses on the general parsing algorithms based on Tomita’s GLR parsing technique. The initial goal of GLR parsing was to provide an efficient algorithm for “practical natural language grammars” [126] by exploiting the efficiency of Knuth’s deterministic LR parser. The BRNGLR algorithm, presented in Chapter 6, is a GLR parsing algorithm that achieves <span class="math notranslate nohighlight">\(O(n^{3})\)</span> worst case complexity. Although the worst case is not always reached, the run time of the algorithm is far from ideal, especially when compared to the deterministic techniques.</p>
<p>Since the run time of a parser is highly visible to a user, there have been several attempts at speeding the run time of LR parsers [1, 2, 126, 127]. Most of these have focused on achieving speed ups by implementing the handle finding automaton in low-level code. A different approach to improving efficiency is presented in [1, 2], the basic ethos of which is to reduce the reliance on the stack. It is clear that the run time performance of shift-reduce parsers is dominated by the maintenance of the parse stack. The recognition of regular languages that are defined by regular expressions, is much more efficient than the parsing of context-free languages that are defined by context-free grammars because only the current state needs to be stored. Informally, Aycock and Horspool’s idea uses FA based recognition techniques for the regular parts of a grammar and only uses a stack for the parts of the grammar which are not regular. (We shall define this formally in detail below.)</p>
<p>Unfortunately, as the authors point out, the algorithm presented in [1] fails to terminate on grammars that contain hidden-left recursion. This chapter presents the Reduction Incorporated Generalised LR (RIGLR) algorithm that is based on thesame approach taken by Aycock and Horspool, but which can be used to parse all context-free grammars correctly. As part of the work in this thesis, the RIGLR algorithm was implemented for comparison with the RNGLR and BRNGLR algorithms. The theoretical description of the RIGLR algorithm given here is taken primarily from [15].</p>
<p>We begin by discussing the role of the stack in a shift-reduce parser and then show how to split a grammar, <span class="math notranslate nohighlight">\(\Gamma\)</span>, into several new grammars for some of the non-terminals that define a regular part of <span class="math notranslate nohighlight">\(\Gamma\)</span>. We then describe the construction of the Intermediate Reduction Incorporated Automata (IRIA) that accept the strings in the language of these regular parts and then use the subset construction algorithm to construct the more deterministic Reduction Incorporated Automata (RIA). Combining the separate RIA to produce the Recursion Call Automaton (RCA) we can recognise the strings in the language of <span class="math notranslate nohighlight">\(\Gamma\)</span> with less stack activity than the GLR parsing techniques. We then introduce the RIGLR algorithm that uses a similar structure to Tomita’s GSS to parse all context-free grammars. The chapter concludes with a discussion on the construction of derivation trees for this algorithm.</p>
<section id="the-role-of-the-stack-in-bottom-up-parsers">
<h2>7.1 The role of the stack in bottom-up parsers<a class="headerlink" href="#the-role-of-the-stack-in-bottom-up-parsers" title="Permalink to this heading">¶</a></h2>
<p>The DFA’s associated with the deterministic bottom-up shift-reduce parsers act as handle recognisers for parsing algorithms. A parse is carried out by reading the input string one symbol at a time and performing a traversal through the DFA from its start state. If an accept state is reached from the input consumed, then the leftmost handle of the input has been located. At this point the parser replaces the string of symbols in the input that match the right hand side of the handle’s production rule, with the non-terminal on the left hand side of the production rule. Parsing then resumes with the modified input string from the start state of the DFA. If an accept state is reached and the start symbol is the only symbol in the input string, then the original string is accepted by the parser.</p>
<p>The approach of repeatedly feeding the input string into the DFA is clearly inefficient. The initial portion of the input may be read several times before its handle is found. Consequently a stack is used to push symbols on when they are read and pop them off when a handle is found. This prevents the initial portion of the input being repeatedly read.</p>
<p>Many parser generators employ an extended BNF notation (EBNF), which includes regular expression operators to encourage structures to be defined in a way that can be efficiently implemented. Although the stack improves a parser’s run time, there are overheads associated with its use, so it is not uncommon for language developers to try and optimise its use; left recursion is preferred to right recursion in bottom-up parsers as the latter causes a deep stack to be created whereas the former yields a shallow stack.</p>
<p>For example, consider the two grammars defined below. Both accept all strings of <span class="math notranslate nohighlight">\(a\)</span>s, but the one on the left uses left recursion whereas the one on the right uses right recursion.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080606573.png" /></p>
<p>A trace of the stacks used during a parse of the string <span class="math notranslate nohighlight">\(aaaa\)</span>, for both grammars defined above, is shown in Table 7.1. The parse of the right recursive grammar shows that the parser needs to remember the entire left context so it can reduce <span class="math notranslate nohighlight">\(a\)</span> the correct number of times. This results in a deeper stack being created.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080606580.png" /></p>
<p>Since a grammar’s DFA is deterministic, one might expect that a path can simply be re-traced once a handle is found without the use of a stack. If this was the case then we could add an <span class="math notranslate nohighlight">\(\epsilon\)</span>-edge from each state with a reduction <span class="math notranslate nohighlight">\((X::=\alpha\cdot)\)</span> to the state at the end of the reduction path whose target is <span class="math notranslate nohighlight">\(X\)</span>. For example, consider Grammar 7.1 and the NFA shown in Figure 7.2. We have added reduction transitions, labelled <span class="math notranslate nohighlight">\(\mathcal{R}i\)</span> where <span class="math notranslate nohighlight">\(i\)</span> is the rule number of the production used in the reduction, to the DFA states that contain items of the form <span class="math notranslate nohighlight">\((X::=\alpha\cdot)\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080607699.png" /></p>
<p>Recall from the Chomsky hierarchy in Chapter 2 that the FA can be used to recognise languages defined by regular grammars. Although Grammar 7.1 is context-free, it defines a regular language. It is therefore not a big surprise that it can be parsed without the use of a stack. Unfortunately, the problem of deciding whether the language of a context-free grammar is regular or not is known to be undecidable [1] and anyway, certain grammars that satisfy this property are difficult to parse without a stack. For example, consider Grammar 7.2 that defines the regular language <span class="math notranslate nohighlight">\(\{bad,dac\}\)</span> and the NFA shown in Figure 7.3.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080608552.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080608942.png" /></p>
<p>Using the NFA above it is possible to reach state 6 after consuming <span class="math notranslate nohighlight">\(ba\)</span> or <span class="math notranslate nohighlight">\(da\)</span>. The state that we should move to after performing the reduction in state 6 depends upon the path that we have taken to get there. After shifting <span class="math notranslate nohighlight">\(ba\)</span> we should move to state 4, but after shifting <span class="math notranslate nohighlight">\(da\)</span> we should move to state 5. However, because there are two <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>-edges leaving state 6 we do not know which one to follow. Using the NFA in Figure 7.3 it is possible to accept the strings <span class="math notranslate nohighlight">\(bad\)</span> and <span class="math notranslate nohighlight">\(dac\)</span> which are not in the language of Grammar 7.2. This is caused by certain multiple instances of non-terminals occurring on the right hand side of production rules. In the example above, it is the non-terminal <span class="math notranslate nohighlight">\(A\)</span> that causes the problem. In a standard LR parser, the stack ensures that the correct path is re-traced in such instances preventing incorrect strings being accepted.</p>
<p>Although one may expect that it is possible to recognise some grammars with multiple instances of non-terminals, since they can be regular and by definition accepted by the FA alone, there are some grammars that contain inherently context-free structures. For example, self embedded recursion is a context-free structure that cannot be recognised by a FA alone. Consider Grammar 7.3 and the NFA constructed with the <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>-edges shown in Figure 7.4.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080608690.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080609289.png" /></p>
<p>Grammar 7.3 defines the language which contains strings of the form <span class="math notranslate nohighlight">\(b^{k}ad^{k}\)</span> for any <span class="math notranslate nohighlight">\(k\geq 0\)</span>. In other words it accepts strings with an equal, or balanced, number of <span class="math notranslate nohighlight">\(b\)</span>s and <span class="math notranslate nohighlight">\(d\)</span>s. Although the NFA in Figure 7.4 correctly recognises these strings, it also accepts strings of the form <span class="math notranslate nohighlight">\(b^{i}ad^{j}\)</span> where <span class="math notranslate nohighlight">\(i\geq 0\)</span> and <span class="math notranslate nohighlight">\(j\geq 0\)</span>, which are not in the language defined by the grammar.</p>
<p>The problem with using an NFA without a stack to recognise a context-free language is caused by the NFA not being able to’remember’ what it has already seen. A stack can be used to ensure that once <span class="math notranslate nohighlight">\(k\)</span><em>bs</em> have been shifted, the parser will reduce exactly <span class="math notranslate nohighlight">\(k\)</span> times.</p>
</section>
<section id="constructing-the-intermediate-reduction-incorporated-automata">
<h2>7.2 Constructing the Intermediate Reduction Incorporated Automata<a class="headerlink" href="#constructing-the-intermediate-reduction-incorporated-automata" title="Permalink to this heading">¶</a></h2>
<p>We have seen in the previous section that a stack is an important part of any shift-reduce parser. A stack guarantees that:</p>
<ul class="simple">
<li><p>when there are multiple instances of non-terminals on the right hand side of the production rules, the parser will move to the correct state after performing a reduction;</p></li>
<li><p>when an instance of self embedded recursion, <span class="math notranslate nohighlight">\(A\stackrel{{+}}{{\Rightarrow}}\alpha A\beta\)</span>, is encountered during a parse the number of matches to <span class="math notranslate nohighlight">\(\alpha\)</span> equals the number of matches to <span class="math notranslate nohighlight">\(\beta\)</span>.</p></li>
</ul>
<p>Although a stack is necessary to correctly recognise the portions of a derivation that rely on the self embedded non-terminals, we can deal with the multiple instances of non-terminals by’multiplying out’ some of the states in the FA. Recall, from Chapter 2, that we construct the LR(0) NFA of a grammar by first creating the individual automata for each of the production rules and then join them together with <span class="math notranslate nohighlight">\(\epsilon\)</span>-edges when a state contains an item with a dot before a non-terminal. For each occurrence of a non-terminal that is encountered in an item, we create a new NFA for that non-terminal’s production rule. We now extend this approach by adding extra NFA states for multiple instances of non-terminals. For example, consider Grammar 2.7, on page 31, and the NFA that has been’multiplied out’ in Figure 7.5.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080609755.png" /></p>
<p>However, if we multiplied out all instances of non-terminals in this way, any recursive rules would result in an infinite number of states being created. For this reason, a recursive instance of a non-terminal <span class="math notranslate nohighlight">\(B\)</span>, in a state that contains an item of the form <span class="math notranslate nohighlight">\((A::=\alpha\cdot B\beta)\)</span>, has an <span class="math notranslate nohighlight">\(\epsilon\)</span>-edge back to the most recent state, on a path from the start state to the current state, that contains an item of the form <span class="math notranslate nohighlight">\((B::=\cdot\gamma)\)</span>. For example consider Grammar 7.4 and the IRIA shown in Figure 7.6.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080609560.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080610025.png" /></p>
<p>Since the rule <span class="math notranslate nohighlight">\(S::=aS\)</span> is right recursive, the state containing the item <span class="math notranslate nohighlight">\((S::=a\cdot S)\)</span> has <span class="math notranslate nohighlight">\(\epsilon\)</span>-edges going back to the states labelled by the items <span class="math notranslate nohighlight">\((S::=\cdot aS)\)</span> and <span class="math notranslate nohighlight">\((S::=\cdot bA)\)</span>. We call the edges which are not created as a result of recursion <em>primary edges</em>.</p>
<p>Recall from Chapter 2 that if a grammar contains a non-terminal <span class="math notranslate nohighlight">\(A\)</span> such that <span class="math notranslate nohighlight">\(A\stackrel{{+}}{{\Rightarrow}}\alpha A\beta\)</span>, where <span class="math notranslate nohighlight">\(\alpha,\beta\neq\epsilon\)</span>, then the grammar contains self-embedding.</p>
<p>A formal definition of the IRIA construction algorithm, taken from [SJ], is given below. It has been proven in [SJ] that for a grammar, <span class="math notranslate nohighlight">\(\Gamma\)</span>, that does not have any self embedded recursion, this algorithm will construct an IRIA that accepts precisely the sentential forms of <span class="math notranslate nohighlight">\(\Gamma\)</span>.</p>
<section id="iria-construction-algorithm">
<h3>IRIA construction algorithm<a class="headerlink" href="#iria-construction-algorithm" title="Permalink to this heading">¶</a></h3>
<p>Given an augmented grammar <span class="math notranslate nohighlight">\(\Gamma\)</span> (without self embedded recursion) we construct an FA IRIA(<span class="math notranslate nohighlight">\(\Gamma\)</span>) as follows:
<strong>Step 1:</strong> Create a node labelled <span class="math notranslate nohighlight">\(S::=\cdot S\)</span>.
<strong>Step 2:</strong> While there are nodes in the FA which are not marked as dealt with, carry out the following:</p>
<ol class="arabic simple">
<li><p>Pick a node <span class="math notranslate nohighlight">\(K\)</span> labelled <span class="math notranslate nohighlight">\((X::=\mu\cdot\gamma)\)</span> which is not marked as dealt with.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(\gamma\neq\epsilon\)</span> then let <span class="math notranslate nohighlight">\(\gamma=x\gamma^{\prime}\)</span> where <span class="math notranslate nohighlight">\(x\in\mathbf{N}\cup\mathbf{T}\)</span>, create a new node, <span class="math notranslate nohighlight">\(M\)</span>, labelled <span class="math notranslate nohighlight">\(X::=\mu x\cdot\gamma^{\prime}\)</span>, and add an arrow labelled <span class="math notranslate nohighlight">\(x\)</span> from <span class="math notranslate nohighlight">\(K\)</span> to <span class="math notranslate nohighlight">\(M\)</span>. This arrow is defined to be a <em>primary edge</em>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(x=Y\)</span>, where <span class="math notranslate nohighlight">\(Y\)</span> is a non-terminal, for each rule <span class="math notranslate nohighlight">\(Y::=\delta\)</span>:</p></li>
<li><p>if there is a node <span class="math notranslate nohighlight">\(L\)</span>, labelled <span class="math notranslate nohighlight">\(Y::=\cdot\delta\)</span>, and a path <span class="math notranslate nohighlight">\(\theta\)</span> from <span class="math notranslate nohighlight">\(L\)</span> to <span class="math notranslate nohighlight">\(K\)</span> which consists of only primary edges and primary <span class="math notranslate nohighlight">\(\epsilon\)</span>-edges (<span class="math notranslate nohighlight">\(\theta\)</span> may be empty),add an arrow labelled <span class="math notranslate nohighlight">\(\epsilon\)</span> from <span class="math notranslate nohighlight">\(K\)</span> to <span class="math notranslate nohighlight">\(L\)</span>. (This new edge is <em>not</em> a primary <span class="math notranslate nohighlight">\(\epsilon\)</span>-edge.)</p></li>
<li><p>if (a) does not hold, create a new node with label <span class="math notranslate nohighlight">\(Y::=\cdot\delta\)</span> and add an arrow labelled <span class="math notranslate nohighlight">\(\epsilon\)</span> from <span class="math notranslate nohighlight">\(K\)</span> to this new node. This is defined to be a <em>primary <span class="math notranslate nohighlight">\(\epsilon\)</span>-edge</em>.</p></li>
<li><p>Mark <span class="math notranslate nohighlight">\(K\)</span> as dealt with.</p></li>
</ol>
<p><strong>Step 3:</strong> Remove all the ‘dealt with’ marks from all nodes.
<strong>Step 4:</strong> While there are nodes labelled <span class="math notranslate nohighlight">\(Y::=\gamma\cdot\)</span> that are not dealt with: pick a node <span class="math notranslate nohighlight">\(K\)</span> labelled <span class="math notranslate nohighlight">\(X::=x_{1}\cdots x_{n}\cdot\)</span> which is not marked as dealt with. Let <span class="math notranslate nohighlight">\(Y::=\gamma\)</span> be rule <span class="math notranslate nohighlight">\(i\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(X\neq S^{\prime}\)</span> then find each node <span class="math notranslate nohighlight">\(L\)</span> labelled <span class="math notranslate nohighlight">\(Z::=\delta\cdot X\rho\)</span> such that there is a path labelled <span class="math notranslate nohighlight">\((\epsilon,x_{1},\cdots,x_{n})\)</span> from <span class="math notranslate nohighlight">\(L\)</span> to <span class="math notranslate nohighlight">\(K\)</span>, then add an arrow labelled <span class="math notranslate nohighlight">\(\mathcal{R}_{i}\)</span> from <span class="math notranslate nohighlight">\(K\)</span> to the child of <span class="math notranslate nohighlight">\(L\)</span> labelled <span class="math notranslate nohighlight">\(Z::=\delta X\cdot\rho\)</span>. Mark <span class="math notranslate nohighlight">\(K\)</span> as dealt with.</p>
<p>The new edge is called a reduction edge, and if the first (<span class="math notranslate nohighlight">\(\epsilon\)</span> labelled) edge of the corresponding path is a primary edge then this new edge is defined to be a <em>primary reduction-edge</em>.</p>
<p><strong>Step 5:</strong> Mark the node labelled <span class="math notranslate nohighlight">\(S^{\prime}::=\cdot S\)</span> as the start node and mark the node labelled <span class="math notranslate nohighlight">\(S^{\prime}::=S^{\cdot}\)</span> as the accepting node.</p>
</section>
</section>
<section id="reducing-non-determinism-in-the-iria">
<h2>7.3 Reducing non-determinism in the IRIA<a class="headerlink" href="#reducing-non-determinism-in-the-iria" title="Permalink to this heading">¶</a></h2>
<p>It is possible to use an IRIA to guide a parser though a derivation for a given string, but since the automaton is non-deterministic, the parser will encounter a choice of actions in certain states. This section presents the <em>Reduction Incorporated Automaton</em> (RIA), a more deterministic automaton than the IRIA which is constructed from the IRIA with the use of the subset construction algorithm.</p>
<p>There are four types of edges in an IRIA. Those labelled by the terminal or non-terminal symbols, the <span class="math notranslate nohighlight">\(\epsilon\)</span>-edges and the <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>-edges. Once the <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>-edges have been created in the IRIA, all the edges labelled with a non-terminal can be removed because they will not be traversed during a parse.</p>
<p>The <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>-edges are used to locate the target state of a reduction. Since no terminal symbols are consumed during their traversal, it is tempting to treat them as <span class="math notranslate nohighlight">\(\epsilon\)</span>-edges during the subset construction. However, since many applications are required to produce a derivation of the input after a parse is complete, we cannot simply combine the states that can be reached by <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>-edges that are labelled with different reductions. Instead we treat them in the same way that we treat the edges labelled by the terminal symbols.</p>
<p>An RIA is constructed from an IRIA by removing the edges labelled by the non-terminal symbols and then performing the subset construction, treating the <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>-edgesas non-empty edges. For example, the RIA in Figure 7.7 was constructed in this way from the IRIA in Figure 7.6.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080612485.png" /></p>
</section>
<section id="regular-recognition">
<h2>7.4 Regular recognition<a class="headerlink" href="#regular-recognition" title="Permalink to this heading">¶</a></h2>
<p>This section describes how to construct the PDA of a context-free grammar <span class="math notranslate nohighlight">\(\Gamma\)</span>, that recognises strings in the language of <span class="math notranslate nohighlight">\(\Gamma\)</span> with a reduced amount of stack activity compared to GLR recognisers. The approach we take is an extension of the method described by Aycock and Horspool in [1]. The description of the algorithm is taken from [11, 12, 13].</p>
<section id="recursion-call-automata">
<h3>7.4.1 Recursion call automata<a class="headerlink" href="#recursion-call-automata" title="Permalink to this heading">¶</a></h3>
<p>Recall that a grammar has self embedded recursion if it contains a non-terminal <span class="math notranslate nohighlight">\(A\)</span>, such that <span class="math notranslate nohighlight">\(A\overset{\pm}{\Rightarrow}\alpha A\beta\)</span> where both <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\neq\epsilon\)</span>. The structures expressed by self embedded recursion are inherently context-free and hence require a stack to be used to ensure that only valid strings are recognised.</p>
<p>We have already established that the amount of stack activity used during recognition can be reduced if we only use it to recognise these context-free structures. By locating the places that self embedded recursion occurs, we can build an automaton that only uses a stack at these places. This automaton is called the Recursion Call Automaton (RCA).</p>
<p>To construct an RCA, we first need to break any self embedded recursion in the grammar. We can achieve this by effectively ‘terminalising’ the non-terminals that appear in the self embedded production rules. We replace a non-terminal <span class="math notranslate nohighlight">\(A\)</span> in a production rule of the form <span class="math notranslate nohighlight">\(X::=\alpha A\beta\)</span>, that has a derivation <span class="math notranslate nohighlight">\(A\overset{\pm}{\Rightarrow}\alpha A\beta\)</span>, with the special terminal symbol <span class="math notranslate nohighlight">\(A^{\perp}\)</span>, in a way that breaks the derivation. We call a grammar <span class="math notranslate nohighlight">\(\Gamma\)</span> that has had all instances of self embedded recursion removed in this way a <em>derived grammar</em> of <span class="math notranslate nohighlight">\(\Gamma\)</span> and denote it by <span class="math notranslate nohighlight">\(\Gamma_{S}\)</span>.</p>
<p>In order to ensure that only the correct derivations of a string are produced (see Section 7.8), we require that any hidden-left recursion is also removed from a grammar before the RCA is constructed. We call the grammar that does not contain any self embedded recursion or hidden-left recursion, the <em>derived parser grammar</em> of <span class="math notranslate nohighlight">\(\Gamma\)</span>.</p>
<p>To build the RCA for a derived parser grammar of a context-free grammar <span class="math notranslate nohighlight">\(\Gamma\)</span>, we build a separate RIA for each of the non-terminals defined in <span class="math notranslate nohighlight">\(\Gamma\)</span> and then link them together. For each of the non-terminals <span class="math notranslate nohighlight">\(A\)</span> (except <span class="math notranslate nohighlight">\(S^{\prime}\)</span> and <span class="math notranslate nohighlight">\(S\)</span>) we create a new rule <span class="math notranslate nohighlight">\(S_{A}::=A\)</span> in <span class="math notranslate nohighlight">\(\Gamma\)</span> and consider the grammar <span class="math notranslate nohighlight">\(\Gamma_{A}\)</span>, which has the same rules as <span class="math notranslate nohighlight">\(\Gamma\)</span> but with the new start rule <span class="math notranslate nohighlight">\(S_{A}::=A\)</span>. We then construct the IRIA and RIA for each <span class="math notranslate nohighlight">\(\Gamma_{A}\)</span>. Once all of the separate, disjoint, RIA have been created, we link them together by removing an edge from a state <span class="math notranslate nohighlight">\(h\)</span> to a state <span class="math notranslate nohighlight">\(k\)</span> that is labelled <span class="math notranslate nohighlight">\(A^{\perp}\)</span> and add a new edge labelled <span class="math notranslate nohighlight">\(p(k)\)</span> from <span class="math notranslate nohighlight">\(h\)</span> to the start state of the RIA<span class="math notranslate nohighlight">\((\Gamma_{A})\)</span>. In addition to this all the accept states of the RIA are labelled with a <span class="math notranslate nohighlight">\(pop\)</span>. The start state and accepting states of the RCA are the same as the start and accept states of <span class="math notranslate nohighlight">\(\Gamma_{S}\)</span>. For example consider Grammar 7.5.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080612304.png" /></p>
<p>Since the non-terminal <span class="math notranslate nohighlight">\(A\)</span> is self embedded, our first step is to terminalise it to produce Grammar 7.6.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080613704.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080613479.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080613487.png" /></p>
<p>It has been proven in [SJ] that a string <span class="math notranslate nohighlight">\(u\)</span> is only in the language of a context-free grammar <span class="math notranslate nohighlight">\(\Gamma\)</span>, if the RCA of <span class="math notranslate nohighlight">\(\Gamma\)</span> accepts <span class="math notranslate nohighlight">\(u\)</span>.</p>
</section>
<section id="parse-table-representation-of-rca">
<h3>7.4.2 Parse table representation of RCA<a class="headerlink" href="#parse-table-representation-of-rca" title="Permalink to this heading">¶</a></h3>
<p>It is often convenient to represent an RCA(<span class="math notranslate nohighlight">\(\Gamma\)</span>) as a parse table, <span class="math notranslate nohighlight">\(\mathcal{T}(\Gamma)\)</span>, where the rows of the table are labelled by the states of the automaton and the columns by the terminal symbols of <span class="math notranslate nohighlight">\(\Gamma\)</span> and the <span class="math notranslate nohighlight">\(\$\)</span> symbol. The parse table entries contain sets of actions corresponding to the actions associated with the states and edges of the RCA. For all edges from state <span class="math notranslate nohighlight">\(h\)</span> to state <span class="math notranslate nohighlight">\(k\)</span>, if the edge is labelled by:</p>
<ul class="simple">
<li><p>a terminal <span class="math notranslate nohighlight">\(x\)</span>, then <span class="math notranslate nohighlight">\(sk\)</span> is in <span class="math notranslate nohighlight">\(\mathcal{T}(h,x)\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathcal{R}i\)</span>, then <span class="math notranslate nohighlight">\(\mathcal{R}(i,k)\)</span> is in all the columns of row <span class="math notranslate nohighlight">\(h\)</span> in <span class="math notranslate nohighlight">\(\mathcal{T}\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(p(l)\)</span>, then <span class="math notranslate nohighlight">\(p(l,k)\)</span> is in all the columns of row <span class="math notranslate nohighlight">\(h\)</span> in <span class="math notranslate nohighlight">\(\mathcal{T}\)</span>;</p></li>
</ul>
<p>(In this version no lookahead is being employed.)
In addition to the actions above, if a state <span class="math notranslate nohighlight">\(h\)</span> in the RCA is labelled <span class="math notranslate nohighlight">\(pop\)</span>, then every column of state <span class="math notranslate nohighlight">\(h\)</span> in <span class="math notranslate nohighlight">\(\mathcal{T}\)</span> also contains a <span class="math notranslate nohighlight">\(pop\)</span> action. So for example, the parse table of the RCA in Figure 7.10 is shown in Table 7.2.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080614123.png" /></p>
</section>
</section>
<section id="generalised-regular-recognition">
<h2>7.5 Generalised regular recognition<a class="headerlink" href="#generalised-regular-recognition" title="Permalink to this heading">¶</a></h2>
<p>This section introduces the RIGLR recognition algorithm which finds a traversal of an RCA for a string <span class="math notranslate nohighlight">\(a_{1}\ldots a_{n}\)</span> if one exists. We begin by providing an informal description of the algorithm and then discuss some specific example grammars that need to be handled with care to ensure that a correct parse is achieved. There is a formal definition of the algorithm at the end of the section.</p>
<p>If there is a traversal, for a given string through an automaton, then that string is in the language defined by the automaton. A straightforward way of determining whether a string is in the language defined by an automaton is to traverse the automaton until all the input has been consumed and an accept state is reached. We can take this approach to traverse an RCA, but since it can be non-deterministic, there may be more than one traversal through the automaton that leads to an accept state for a given string. We are interested in finding all such paths, so we employ a breadth first search approach to follow all possible traversals when a choice arises.</p>
<p>A straightforward approach to traversing such a non-deterministic automaton is to maintain a set of states that can be reached by traversing the edges that do not consume any input symbols. In this case, it is the edges labelled by <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>. We achieve this by maintaining a set <span class="math notranslate nohighlight">\(U_{i}\)</span>, where <span class="math notranslate nohighlight">\(0\leq i\leq n\)</span>, during the parse of a string <span class="math notranslate nohighlight">\(a_{1}\ldots a_{n}\)</span>. We begin by constructing the set <span class="math notranslate nohighlight">\(U_{0}\)</span> that contains the start state of the RCA and then add, in a similar way to the standard subset construction algorithm [1], all the states that can be reached by traversing the edges from the start state that do not consume any input symbols. When no more states can be added to the set <span class="math notranslate nohighlight">\(U_{0}\)</span> its construction is complete. We then proceed to create the set <span class="math notranslate nohighlight">\(U_{i+1}\)</span> from <span class="math notranslate nohighlight">\(U_{i}\)</span> by adding the states that can be reached by traversing an edge labelled with the current input symbol, <span class="math notranslate nohighlight">\(a_{i+1}\)</span>, from each state in <span class="math notranslate nohighlight">\(U_{i}\)</span>. An input string is accepted, if after consuming all input symbols the set <span class="math notranslate nohighlight">\(U_{n}\)</span> contains the RCA’s accept state.</p>
<p>This approach only works if the RCA’s underlying language does not contain any nested structures. If it does, then the RCA will contain push transitions labelled <span class="math notranslate nohighlight">\(p(X)\)</span>, where <span class="math notranslate nohighlight">\(X\)</span> is a state number. When such an edge is traversed it is necessary to remember <span class="math notranslate nohighlight">\(X\)</span>, since a state containing a pop action will eventually be reached that requires the parser to goto <span class="math notranslate nohighlight">\(X\)</span>. It is tempting to store the return state in the set <span class="math notranslate nohighlight">\(U\)</span>, along with the action’s source state, but the possibility of nested pushes and multiple paths caused by the non-determinism would make this approach inefficient.</p>
<p>We take the approach described by Aycock and Horspool in [1] and use a graph structure, similar to Tomita’s GSS (see Chapter 4), to record the return states of the push actions. We call this graph structure the <em>Recursive Call Graph</em> (RCG). When we encounter a push action during the traversal of the RCA with a return state <span class="math notranslate nohighlight">\(l\)</span> and a target state <span class="math notranslate nohighlight">\(k\)</span>, we create a node <span class="math notranslate nohighlight">\(q\)</span> labelled <span class="math notranslate nohighlight">\(l\)</span> in the RCG and add the pair <span class="math notranslate nohighlight">\((k,q)\)</span> to the current set <span class="math notranslate nohighlight">\(U_{i}\)</span>.</p>
<p>Consider Grammar 7.5 and the RCA constructed in Section 7.4. We parse the string <span class="math notranslate nohighlight">\(cbad\)</span> by first creating the base node, <span class="math notranslate nohighlight">\(q_{0}\)</span>, of the RCG, labelled -1 (which is not the state number of any RCA state), and then add the element <span class="math notranslate nohighlight">\((0,q_{0})\)</span> to the set <span class="math notranslate nohighlight">\(U_{0}\)</span>. Since the only edge that leaves state <span class="math notranslate nohighlight">\(0\)</span> is labelled by the terminal <span class="math notranslate nohighlight">\(c\)</span>, which matches the first symbol on the input string, we move to state <span class="math notranslate nohighlight">\(1\)</span>, and construct the new set <span class="math notranslate nohighlight">\(U_{1}=\{(1,q_{0})\}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080614463.png" /></p>
<p>There are two edges from state 1, but since they are both labelled by terminal symbols we do not add anything to U1 in this step. The next input symbol is b, so we traverse the edge to state 2, create <span class="math notranslate nohighlight">\(U2 = {(2, q_0)}\)</span>. Since there is an edge labelled <span class="math notranslate nohighlight">\(p(4)\)</span> from state 2, we create the new RCG node, q1, labelled 4 and then add (8,q1) to <span class="math notranslate nohighlight">\(U2\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080619737.png" /></p>
<p>The only edges leaving state 8 are labelled by terminal symbols, so we shift on the next input symbol which takes us from state 8, to state 10. We traverse the R-edges so that <span class="math notranslate nohighlight">\(U3 = {(10,q1),(13,q1)}\)</span>. Since state 13 contains a pop action, we pop 4, which is the label of node q1 in the RCG, and add the element <span class="math notranslate nohighlight">\((4,q0)\)</span> to <span class="math notranslate nohighlight">\(U3\)</span>.</p>
<p>At this point we have <span class="math notranslate nohighlight">\(U3 = {(10,q_1),(13,q_1),(4,q_0)}\)</span> and since there are no more edges that can be traversed without consuming any input symbols the third step of the algorithm is complete.</p>
<p>We then read the final symbol from the input string and traverse the edge labelled <span class="math notranslate nohighlight">\(d\)</span> to state 5 creating <span class="math notranslate nohighlight">\(U_{4}=\{(5,q_{0})\}\)</span>. We traverse the <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>-edges and construct <span class="math notranslate nohighlight">\(U_{4}=\{(5,q_{0}),(6,q_{0}),(7,q_{0})\}\)</span>. Since the next input symbol is the end-of-string symbol, <span class="math notranslate nohighlight">\(\$\)</span>, and <span class="math notranslate nohighlight">\(U\)</span> contains the element <span class="math notranslate nohighlight">\((7,q_{0})\)</span> which has the accept state of the RCA and the base node of the stack, the input <span class="math notranslate nohighlight">\(cbad\)</span> is accepted.
Before we give the formal definition of the algorithm, we will discuss and show the construction of the RCG for three example grammars that can cause problems if they are not handled with care.</p>
<section id="example-right-and-hidden-left-recursion">
<h3>Example - right and hidden-left recursion<a class="headerlink" href="#example-right-and-hidden-left-recursion" title="Permalink to this heading">¶</a></h3>
<p>Right and hidden-left recursive grammars cause loops of reductions to be created in the RCA. The RIGLR algorithm works by first doing all the reductions that are possible from a state in the RCA before doing any of the other actions. When there are loops of reductions in the RCA, care needs to be taken that the traversal algorithm will terminate. To ensure this we only add the pair <span class="math notranslate nohighlight">\((q,k)\)</span> to the set <span class="math notranslate nohighlight">\(U_{i}\)</span> once in each step of the algorithm.</p>
<p>For example, consider the right recursive Grammar 7.4 on page 149, and the RCA shown in Figure 7.11 that has been constructed from the RIA in Figure 7.7 on page 152.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080619529.png" /></p>
<p>To parse the string <span class="math notranslate nohighlight">\(ab\)</span> we begin by constructing the base node of the RCG labelled -1 and add <span class="math notranslate nohighlight">\((0,q_{0})\)</span> to the set <span class="math notranslate nohighlight">\(U\)</span>. Since there are no push or pop actions in the RCA, only the base node of the RCG will be used during the parse. As a result we shall not show the RCG during this example.</p>
<p>The first input symbol is <span class="math notranslate nohighlight">\(a\)</span>, so we traverse the edge from state 0 to state 1 and add <span class="math notranslate nohighlight">\((1,q_{0})\)</span> to <span class="math notranslate nohighlight">\(U_{1}\)</span>. Since the only transitions from state 1 are labelled by terminal symbols, we read the final input symbol, <span class="math notranslate nohighlight">\(b\)</span> and traverse the edge to state 2. At this point <span class="math notranslate nohighlight">\(U_{2}=\{(2,q_{0})\}\)</span>. We continue by traversing the edge labelled <span class="math notranslate nohighlight">\(\mathcal{R}4\)</span> to state 3 and from there the <span class="math notranslate nohighlight">\(\mathcal{R}2\)</span> edge to the accepting state <span class="math notranslate nohighlight">\(5\)</span>, adding <span class="math notranslate nohighlight">\((3,q_{0})\)</span> and <span class="math notranslate nohighlight">\((5,q_{0})\)</span> to <span class="math notranslate nohighlight">\(U_{2}\)</span>.</p>
<p>Although we can accept the input at this point, there is an edge labelled <span class="math notranslate nohighlight">\(\mathcal{R}1\)</span> from the accepting state which still needs to be traversed. However, since the edge loops back to the same state without consuming any input symbols, we run the risk of repeatedly adding <span class="math notranslate nohighlight">\((5,q_{0})\)</span> to <span class="math notranslate nohighlight">\(U_{2}\)</span>. For this reason, we do not remove elements from <span class="math notranslate nohighlight">\(U_{i}\)</span> once their state has been processed and ensure that no element is added to <span class="math notranslate nohighlight">\(U_{i}\)</span> more than once.</p>
</section>
<section id="example-further-issues-surrounding-hidden-left-recursion">
<h3>Example - further issues surrounding hidden-left recursion<a class="headerlink" href="#example-further-issues-surrounding-hidden-left-recursion" title="Permalink to this heading">¶</a></h3>
<p>When a push action is encountered, the traversal algorithm adds a new state to the RCG. If a grammar has a self embedded, hidden-left recursive non-terminal, the traversal algorithm will fail to terminate if a new state is added for every push action. This is because of a loop in the RCA that will not consume any input symbols before doing a push. To prevent the algorithm from failing to terminate, we take a similar approach to Farshi’s modification of Tomita’s algorithm - we introduce loops in the RCG.</p>
<p>To achieve this we maintain a list, <span class="math notranslate nohighlight">\(\mathcal{P}_{i}\)</span>, of the RCG nodes constructed in each step of the algorithm. If a node with the same label has already been constructed we re-use it. <span class="math notranslate nohighlight">\(\mathcal{P}_{i}\)</span> is initialised with the base node and is cleared after an input symbol is read. (To help to see what is going on when we draw an RCG we put nodes constructed at the same step in the algorithm vertically above each other in the RCG.)</p>
<p>So, for example consider the parse of the string <span class="math notranslate nohighlight">\(bc\)</span> in the language of Grammar 7.7 [15]. Notice that the non-terminal <span class="math notranslate nohighlight">\(S\)</span> is both self embedded and hidden-left recursive.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080620723.png" /></p>
<p>Since the grammar contains self embedded recursion, we terminalise the grammar to produce Grammar 7.8. The IRIA, RIA and RCA constructed for Grammar 7.8 are shown in Figures 7.12, 7.13 and 7.14 respectively.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080621857.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080621199.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080621745.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310080622159.png" /></p>
<p>We begin the parse by creating the base node of the RCG and adding the element <span class="math notranslate nohighlight">\((0,q_{0})\)</span> to the set <span class="math notranslate nohighlight">\(U_{0}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{P}_{i}\)</span>. Before consuming any of the input string it is necessary to traverse any edges labelled by push or <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> actions. From state <span class="math notranslate nohighlight">\(0\)</span> we traverse the edge labelled <span class="math notranslate nohighlight">\(\mathcal{R}4\)</span> to state <span class="math notranslate nohighlight">\(3\)</span>, add <span class="math notranslate nohighlight">\((3,q_{0})\)</span> to <span class="math notranslate nohighlight">\(U_{0}\)</span> and then traverse the edge labelled by <span class="math notranslate nohighlight">\(p(4)\)</span>. The push action results in a new node, <span class="math notranslate nohighlight">\(q_{1}\)</span>, labelled <span class="math notranslate nohighlight">\(4\)</span>, being created in the RCG with an edge back to node <span class="math notranslate nohighlight">\(q_{0}\)</span>. The state of the RCG and the contents of the set <span class="math notranslate nohighlight">\(U_{0}\)</span> and <span class="math notranslate nohighlight">\({\cal P}_{i}\)</span>, at this point of the parse, are shown below.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081618439.png" />
It is necessary to traverse the reduction transition, <span class="math notranslate nohighlight">\({\cal R}4\)</span>, from state <span class="math notranslate nohighlight">\(0\)</span> once again for the process <span class="math notranslate nohighlight">\((0,q_{1})\)</span>. Performing the reduction we add <span class="math notranslate nohighlight">\((3,q_{1})\)</span> to <span class="math notranslate nohighlight">\(U_{0}\)</span> and then proceed to traverse the push transition <span class="math notranslate nohighlight">\(p(4)\)</span>. Since there is already a node, <span class="math notranslate nohighlight">\(q_{1}\)</span>, labelled <span class="math notranslate nohighlight">\(4\)</span> in <span class="math notranslate nohighlight">\({\cal P}_{0}\)</span> we shall re-use it and simply add a loop to it as shown below.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081619376.png" /></p>
<p>There are no more edges that can be traversed from the RCA nodes in <span class="math notranslate nohighlight">\(U_{0}\)</span> that do not consume any input symbols so the first step of the algorithm is complete. We read the next input symbol, <span class="math notranslate nohighlight">\(a\)</span>, and construct <span class="math notranslate nohighlight">\(U_{1}=\{(2,q_{0}),(2,q_{1})\}\)</span> and set <span class="math notranslate nohighlight">\({\cal P}_{1}=\emptyset\)</span>. We then traverse the edge labelled <span class="math notranslate nohighlight">\({\cal R}3\)</span> to state <span class="math notranslate nohighlight">\(3\)</span> and add <span class="math notranslate nohighlight">\((3,q_{0})\)</span> and <span class="math notranslate nohighlight">\((3,q_{1})\)</span> to <span class="math notranslate nohighlight">\(U_{1}\)</span>. From state <span class="math notranslate nohighlight">\(3\)</span> there is the edge labelled <span class="math notranslate nohighlight">\(p(4)\)</span> so we create a new RCG node, <span class="math notranslate nohighlight">\(q_{2}\)</span>, labelled <span class="math notranslate nohighlight">\(4\)</span> with edges back to <span class="math notranslate nohighlight">\(q_{0}\)</span> and <span class="math notranslate nohighlight">\(q_{1}\)</span> and add <span class="math notranslate nohighlight">\((0,q_{2})\)</span> to <span class="math notranslate nohighlight">\(U_{1}\)</span> and <span class="math notranslate nohighlight">\({\cal P}_{1}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081619544.png" /></p>
<p>From state <span class="math notranslate nohighlight">\(0\)</span> there is a reduction edge labelled <span class="math notranslate nohighlight">\({\cal R}4\)</span> that goes back to state <span class="math notranslate nohighlight">\(3\)</span>. We traverse the edge, add <span class="math notranslate nohighlight">\((3,q_{2})\)</span> to <span class="math notranslate nohighlight">\(U_{1}\)</span> and then traverse the push edge once again. Since node <span class="math notranslate nohighlight">\(q_{2}\)</span>, that is labelled <span class="math notranslate nohighlight">\(4\)</span>, has already been created during this step of the algorithm, we add a loop to it and do not create any new nodes.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081620450.png" /></p>
<p>We proceed by reading the next input symbol, <span class="math notranslate nohighlight">\(b\)</span>, performing the traversal from state <span class="math notranslate nohighlight">\(0\)</span> to state <span class="math notranslate nohighlight">\(1\)</span> and then construct <span class="math notranslate nohighlight">\(U_{2}=\{(1,q_{2})\}\)</span> and set <span class="math notranslate nohighlight">\(\mathcal{P}_{2}=\emptyset\)</span>. We then traverse the reduction edge labelled <span class="math notranslate nohighlight">\(\mathcal{R}2\)</span> from state <span class="math notranslate nohighlight">\(1\)</span> to state <span class="math notranslate nohighlight">\(5\)</span> and add <span class="math notranslate nohighlight">\((5,q_{2})\)</span> to <span class="math notranslate nohighlight">\(U_{2}\)</span>. Since state <span class="math notranslate nohighlight">\(5\)</span> contains a pop action, we find the children, <span class="math notranslate nohighlight">\(q_{0},q_{1},q_{2}\)</span>, of the RCG node <span class="math notranslate nohighlight">\(q_{2}\)</span> and add the new elements <span class="math notranslate nohighlight">\((4,q_{0}),(4,q_{1})\)</span> and <span class="math notranslate nohighlight">\((4,q_{2})\)</span> to <span class="math notranslate nohighlight">\(U_{2}\)</span>.</p>
<p>That completes step <span class="math notranslate nohighlight">\(2\)</span> of the algorithm, so we read the final input symbol, <span class="math notranslate nohighlight">\(c\)</span>, traverse the edge labelled <span class="math notranslate nohighlight">\(c\)</span> from state <span class="math notranslate nohighlight">\(4\)</span> to state <span class="math notranslate nohighlight">\(6\)</span> and construct <span class="math notranslate nohighlight">\(U_{3}=\{(6,q_{0}),(6,q_{1}),(6,q_{2})\}\)</span> and set <span class="math notranslate nohighlight">\(\mathcal{P}_{3}=\emptyset\)</span>. Traversing the reduction, <span class="math notranslate nohighlight">\(\mathcal{R}1\)</span>, from state <span class="math notranslate nohighlight">\(6\)</span> to state <span class="math notranslate nohighlight">\(5\)</span>, we add <span class="math notranslate nohighlight">\((5,q_{0}),(5,q_{1})\)</span> and <span class="math notranslate nohighlight">\((5,q_{2})\)</span> to <span class="math notranslate nohighlight">\(U_{3}\)</span>. We then perform the pop actions associated with state <span class="math notranslate nohighlight">\(5\)</span> of the RCA for <span class="math notranslate nohighlight">\((5,q_{1})\)</span> and <span class="math notranslate nohighlight">\((5,q_{2})\)</span> which result in <span class="math notranslate nohighlight">\((4,q_{0})\)</span> and <span class="math notranslate nohighlight">\((4,q_{1})\)</span> respectively, being added to <span class="math notranslate nohighlight">\(U_{3}\)</span>. No pop is done for <span class="math notranslate nohighlight">\((5,q_{0})\)</span> since <span class="math notranslate nohighlight">\(q_{0}\)</span> is the base node of the RCG. At this point <span class="math notranslate nohighlight">\(U_{3}=\{((6,q_{0}),(6,q_{1}),(6,q_{2}),(5,q_{0}),(5,q_{1}),(5,q_{2})(4,q_{0}), (4,q_{1})\}\)</span>.</p>
<p>Since all the input has been consumed and the process <span class="math notranslate nohighlight">\((5,q_{0})\)</span> is in <span class="math notranslate nohighlight">\(U_{3}\)</span>, where state <span class="math notranslate nohighlight">\(5\)</span> is the accepting state of the RCA and <span class="math notranslate nohighlight">\(q_{0}\)</span> is the RCG’s base node, the input string <span class="math notranslate nohighlight">\(abc\)</span> is accepted.</p>
</section>
<section id="example-ensuring-all-pop-actions-are-done">
<h3>Example - ensuring all pop actions are done<a class="headerlink" href="#example-ensuring-all-pop-actions-are-done" title="Permalink to this heading">¶</a></h3>
<p>When a pop action is performed by the algorithm on a node <span class="math notranslate nohighlight">\(q\)</span> with label <span class="math notranslate nohighlight">\(h\)</span> that has an edge to another node <span class="math notranslate nohighlight">\(p\)</span> in the RCG, the element <span class="math notranslate nohighlight">\((h,p)\)</span> is added to the set <span class="math notranslate nohighlight">\(U_{i}\)</span>. If a new edge is added from node <span class="math notranslate nohighlight">\(q\)</span> to another node <span class="math notranslate nohighlight">\(w\)</span>, in the same step of the algorithm, then we need to perform the <span class="math notranslate nohighlight">\(pop\)</span> action down this new edge. To ensure that this is done, when we add a new edge between <span class="math notranslate nohighlight">\(q\)</span> and <span class="math notranslate nohighlight">\(w\)</span>, we check to see if <span class="math notranslate nohighlight">\(U_{i}\)</span> contains a process which results in a pop action being performed from <span class="math notranslate nohighlight">\(q\)</span>. If such a process exists then we make sure that <span class="math notranslate nohighlight">\(U_{i}\)</span> contains the process <span class="math notranslate nohighlight">\((h,w)\)</span>.</p>
<p>For example, consider Grammar 7.9, taken from [15], and the terminalised version, Grammar 7.10. The associated IRIA, RIA and RCA are shown in Figures 7.15, 7.16 and 7.17 respectively.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081621757.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081621225.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081621519.png" /></p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081621341.png" /></p>
<p>To parse the string <span class="math notranslate nohighlight">\(b\)</span> we begin by creating the base node of the RCG, <span class="math notranslate nohighlight">\(q_{0}\)</span>, and add the process <span class="math notranslate nohighlight">\((0,q_{0})\)</span> to <span class="math notranslate nohighlight">\(U_{0}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{P}_{0}\)</span>. From state <span class="math notranslate nohighlight">\(0\)</span> in the RCA we move to state <span class="math notranslate nohighlight">\(1\)</span> on a transition labelled by <span class="math notranslate nohighlight">\(\mathcal{R}2\)</span> and add the process <span class="math notranslate nohighlight">\((1,q_{0})\)</span> to <span class="math notranslate nohighlight">\(U_{0}\)</span>. Although state <span class="math notranslate nohighlight">\(1\)</span> contains a pop action, nothing is done since <span class="math notranslate nohighlight">\(q_{0}\)</span> does not have any children. We then traverse the edge labelled <span class="math notranslate nohighlight">\(p(2)\)</span> back to state <span class="math notranslate nohighlight">\(0\)</span>, create the new RCG node, <span class="math notranslate nohighlight">\(q_{1}\)</span>, with an edge to <span class="math notranslate nohighlight">\(q_{0}\)</span>, and add <span class="math notranslate nohighlight">\((0,q_{1})\)</span> to <span class="math notranslate nohighlight">\(U_{0}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{P}_{0}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081622124.png" /></p>
<p>From state <span class="math notranslate nohighlight">\(0\)</span> we traverse the <span class="math notranslate nohighlight">\(\mathcal{R}2\)</span> edge to state <span class="math notranslate nohighlight">\(1\)</span> and add the process <span class="math notranslate nohighlight">\((1,q_{1})\)</span> to <span class="math notranslate nohighlight">\(U_{0}\)</span>. At this point we can perform the pop action associated with state <span class="math notranslate nohighlight">\(1\)</span>. We find the only child of <span class="math notranslate nohighlight">\(q_{1}\)</span>, <span class="math notranslate nohighlight">\(q_{0}\)</span>, and add <span class="math notranslate nohighlight">\((2,q_{0})\)</span> to <span class="math notranslate nohighlight">\(U_{0}\)</span>. Traversing the edge labelled <span class="math notranslate nohighlight">\(p(2)\)</span> from state <span class="math notranslate nohighlight">\(1\)</span> to state <span class="math notranslate nohighlight">\(0\)</span>, we first search <span class="math notranslate nohighlight">\(\mathcal{P}_{0}\)</span> to see if a node labelled <span class="math notranslate nohighlight">\(2\)</span> has been created during this step of the algorithm. Since <span class="math notranslate nohighlight">\(q_{1}\)</span> is in <span class="math notranslate nohighlight">\(\mathcal{P}_{0}\)</span> we re-use it and add a new edge from <span class="math notranslate nohighlight">\(q_{1}\)</span> to itself. However, the new edge on <span class="math notranslate nohighlight">\(q_{1}\)</span> has created a new path down which the previous pop action could be performed. It is therefore necessary to add <span class="math notranslate nohighlight">\((2,q_{1})\)</span> to <span class="math notranslate nohighlight">\(U_{0}\)</span>. The current state of the RCG and the contents of the sets <span class="math notranslate nohighlight">\(U_{0}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{P}_{0}\)</span> are shown below.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081622204.png" />
We continue the parse by traversing the edge labelled with the push action, <span class="math notranslate nohighlight">\(p(3)\)</span>, from state <span class="math notranslate nohighlight">\(2\)</span> to state <span class="math notranslate nohighlight">\(0\)</span>, create the new RCG node, <span class="math notranslate nohighlight">\(q_{2}\)</span>, labelled <span class="math notranslate nohighlight">\(3\)</span>, with two edges. One edge goes from <span class="math notranslate nohighlight">\(q_{2}\)</span> to <span class="math notranslate nohighlight">\(q_{0}\)</span> and the other from <span class="math notranslate nohighlight">\(q_{2}\)</span> to <span class="math notranslate nohighlight">\(q_{1}\)</span>. We also add <span class="math notranslate nohighlight">\((0,q_{2})\)</span> to <span class="math notranslate nohighlight">\(U_{0}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{P}_{0}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081622239.png" /></p>
<p>We then traverse the <span class="math notranslate nohighlight">\(\mathcal{R}2\)</span> edge to state <span class="math notranslate nohighlight">\(1\)</span>, add <span class="math notranslate nohighlight">\((1,q_{2})\)</span> to <span class="math notranslate nohighlight">\(U_{0}\)</span> and proceed to perform the pop on <span class="math notranslate nohighlight">\(q_{2}\)</span>. We find the children of <span class="math notranslate nohighlight">\(q_{2}\)</span>, <span class="math notranslate nohighlight">\(q_{0}\)</span> and <span class="math notranslate nohighlight">\(q_{1}\)</span>, and add <span class="math notranslate nohighlight">\((3,q_{0})\)</span> and <span class="math notranslate nohighlight">\((3,q_{1})\)</span> to <span class="math notranslate nohighlight">\(U_{0}\)</span>. Traversing the edge labelled <span class="math notranslate nohighlight">\(p(2)\)</span> from state <span class="math notranslate nohighlight">\(1\)</span> to state <span class="math notranslate nohighlight">\(0\)</span>, we re-use <span class="math notranslate nohighlight">\(q_{1}\)</span> and add a new edge from <span class="math notranslate nohighlight">\(q_{1}\)</span> to <span class="math notranslate nohighlight">\(q_{2}\)</span>. This new edge has created a new path down which the previous pop action could be performed so we add <span class="math notranslate nohighlight">\((2,q_{2})\)</span> to <span class="math notranslate nohighlight">\(U_{0}\)</span>. When we perform the push transition, <span class="math notranslate nohighlight">\(p3\)</span>, from state <span class="math notranslate nohighlight">\(2\)</span> of the RCA (as a result of <span class="math notranslate nohighlight">\((2,q_{2})\)</span> being added to <span class="math notranslate nohighlight">\(U_{0}\)</span>) we create a new looping edge for <span class="math notranslate nohighlight">\(q_{2}\)</span>. Since a pop we already performed can also be performed down this new edge, we also add <span class="math notranslate nohighlight">\((3,q_{2})\)</span> to <span class="math notranslate nohighlight">\(U_{0}\)</span>. That completes the first step of the algorithm. The current state of the RCG and the contents of the sets <span class="math notranslate nohighlight">\(U_{0}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{P}_{0}\)</span> are shown below.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081624160.png" /></p>
<p>We then read the next input symbol <span class="math notranslate nohighlight">\(b\)</span>, construct the new set <span class="math notranslate nohighlight">\(U_{1}=\{(4,q_{0}),(4,q_{1}),(4,q_{2})\}\)</span> and set <span class="math notranslate nohighlight">\(\mathcal{P}_{1}=\emptyset\)</span>. We traverse the <span class="math notranslate nohighlight">\(\mathcal{R}1\)</span> edge to state <span class="math notranslate nohighlight">\(1\)</span>, add <span class="math notranslate nohighlight">\((1,q_{0}),(1,q_{1}),(1,q_{2})\)</span> to <span class="math notranslate nohighlight">\(U_{1}\)</span> and then perform the associated pop action for <span class="math notranslate nohighlight">\(q_{1}\)</span> and <span class="math notranslate nohighlight">\(q_{2}\)</span>. We add <span class="math notranslate nohighlight">\((2,q_{0}),(2,q_{1}),(2,q_{2})\)</span> and <span class="math notranslate nohighlight">\((3,q_{0}),(3,q_{1}),(3,q_{2})\)</span> to <span class="math notranslate nohighlight">\(U_{1}\)</span>. Traversing the push transition, <span class="math notranslate nohighlight">\(p2\)</span>, from state <span class="math notranslate nohighlight">\(1\)</span>, we create a new RCG node, <span class="math notranslate nohighlight">\(q_{3}\)</span>, labelled <span class="math notranslate nohighlight">\(2\)</span> and add edges from it to the nodes <span class="math notranslate nohighlight">\(q_{0},q_{1}\)</span> and <span class="math notranslate nohighlight">\(q_{2}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081624033.png" />
Continuing the parse in this way results in the creation of the final RCG shown below.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081625034.png" /></p>
<p>Since all the input has been consumed and the process <span class="math notranslate nohighlight">\((1,q_{0})\)</span> is in <span class="math notranslate nohighlight">\(U_{1}\)</span>, where state <span class="math notranslate nohighlight">\(1\)</span> is the accepting state of the RCA and <span class="math notranslate nohighlight">\(q_{0}\)</span> is the RCG’s base node, the input string <span class="math notranslate nohighlight">\(b\)</span> is accepted.</p>
</section>
<section id="riglr-recogniser">
<h3>RIGLR recogniser<a class="headerlink" href="#riglr-recogniser" title="Permalink to this heading">¶</a></h3>
<p><img alt="Layer 3.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081633055.png" /></p>
</section>
</section>
<section id="reducing-the-non-determinism-in-the-rca">
<h2>7.6 Reducing the non-determinism in the RCA<a class="headerlink" href="#reducing-the-non-determinism-in-the-rca" title="Permalink to this heading">¶</a></h2>
<p>We can reduce the amount of non-determinism in the RCA by adding lookahead sets to the reduce, push and pop actions. The lookahead sets are calculated for the reduce and push actions by traversing the <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>-edges and push edges until a state is reached that has edges leaving it that are labelled by terminal symbols. These terminals are added to the lookahead set of all the edges on the path to the state. If the target state is an accept state then the lookahead set also includes the <span class="math notranslate nohighlight">\(\$\)</span> symbol.</p>
<p>Since the pop action is part of a state, we label the state with a lookahead set which is calculated by finding the lookahead sets of the states that can be reached when the pop action is performed. These states are the targets of the edges labelled by the terminalised symbols in the RIA.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081634961.png" /></p>
<p>The implementation used in PAT does not incorporate lookahead because the RCA are produced by GTB and GTB does not, at present, construct RCA with lookahead.</p>
<section id="reducing-the-number-of-processes-in-each-u-i">
<h3>Reducing the number of processes in each <span class="math notranslate nohighlight">\(U_{i}\)</span><a class="headerlink" href="#reducing-the-number-of-processes-in-each-u-i" title="Permalink to this heading">¶</a></h3>
<p>The number of processes added to <span class="math notranslate nohighlight">\(U_{i}\)</span> at each step of the RIGLR algorithm can be very large. An approach to reduce both the size of the RCA and the number of processes added at each step of the algorithm is presented in [1]. It involves ‘pre-compiling’ and then combining sequences of actions in the RCA. The basic principle is to combine a preceding terminal that can be shifted, with all <span class="math notranslate nohighlight">\(\mathcal{R}\)</span>-edges, and/or a following push edge. For example, consider the pre-compiled RCA shown in Figure 7.19 that has been constructed from the RCA in Figure 7.18.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081634810.png" />
Although this approach can reduce the size of the RCA, if we want to incorporate lookahead into the RCA, we have to use two symbols of lookahead. This will increase the size of the parse table and hence also the size of the parser. More seriously, if all possible sequences of reductions are composed then the number of new edges in the RCA can be increased from <span class="math notranslate nohighlight">\(O(k)\)</span> to <span class="math notranslate nohighlight">\(O(2^{k+1})\)</span>. An example of this is given in [15].
However, limited composition has been proposed in [15] that guarantees not to increase the size of the RCA. The implementation used in PAT does not incorporate this technique to reduce the size of the sets <span class="math notranslate nohighlight">\(U_{i}\)</span>.</p>
</section>
</section>
<section id="generalised-regular-parsing">
<h2>7.8 Generalised regular parsing<a class="headerlink" href="#generalised-regular-parsing" title="Permalink to this heading">¶</a></h2>
<p>This section introduces the RIGLR parsing algorithm which attempts to find a traversal of an RCA for a string <span class="math notranslate nohighlight">\(a_{1}\ldots a_{n}\)</span> and constructs a syntactic representation of the string. We begin by providing an informal description of how to build a derivation tree using an example for which the RCA is deterministic. Then we present an efficient way of representing multiple derivations. There is a formal definition of the algorithm at the end of the section.</p>
<section id="constructing-derivation-trees">
<h3>7.8.1 Constructing derivation trees<a class="headerlink" href="#constructing-derivation-trees" title="Permalink to this heading">¶</a></h3>
<p>We can build a derivation tree for an input string <span class="math notranslate nohighlight">\(a_{1}\ldots a_{n}\)</span> during a parse by maintaining a sequence of tree nodes, <span class="math notranslate nohighlight">\(u_{1},\ldots,u_{p}\)</span>, constructed at each step of the algorithm. When an edge labelled with a terminal symbol, <span class="math notranslate nohighlight">\(a\)</span>, is traversed, we create a parse tree node and append it to the sequence of nodes created thus far. When a <span class="math notranslate nohighlight">\(\mathcal{R}_{i}\)</span> edge is traversed, where rule <span class="math notranslate nohighlight">\(i\)</span> is <span class="math notranslate nohighlight">\(A::=x_{1}\ldots x_{k}\)</span>, we remove nodes, <span class="math notranslate nohighlight">\(u_{p-k+1},\ldots,u_{p}\)</span>, from the sequence, create a new node labelled <span class="math notranslate nohighlight">\(A\)</span>, with children <span class="math notranslate nohighlight">\(u_{p-k+1},\cdots,u_{p}\)</span>, and append the new node to the end of the sequence. No tree nodes need to be created for the push and pop transitions of the RCA.</p>
<p>Figure 7.19: The reduced RCA of Grammar 7.6 with lookahead.</p>
<p>For example, consider the parse of the string <span class="math notranslate nohighlight">\(cbad\)</span> for Grammar 7.6 and its associated RCA shown in Figure 7.10 (see page 7.10). We shall maintain the parse tree root nodes in the sequence <span class="math notranslate nohighlight">\(\mathcal{W}\)</span>.</p>
<p>We begin the parse, as usual, by creating the base node of the RCG and adding the element <span class="math notranslate nohighlight">\((0,q_{0})\)</span> to the set <span class="math notranslate nohighlight">\(U_{0}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{P}_{0}\)</span>. We read the first input symbol <span class="math notranslate nohighlight">\(c\)</span>, traverse the edge from state <span class="math notranslate nohighlight">\(0\)</span> to state <span class="math notranslate nohighlight">\(1\)</span>, create the first parse tree node, <span class="math notranslate nohighlight">\(w_{0}\)</span>, labelled c and construct the set <span class="math notranslate nohighlight">\(U_{1}=\{(1,q_{0})\}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081635145.png" /></p>
<p>We continue the parse by reading the next input symbol, <span class="math notranslate nohighlight">\(b\)</span>, traversing the edge from state <span class="math notranslate nohighlight">\(1\)</span>, labelled <span class="math notranslate nohighlight">\(b\)</span>, to state <span class="math notranslate nohighlight">\(2\)</span>, create the new parse tree node, <span class="math notranslate nohighlight">\(w_{1}\)</span>, and construct the set <span class="math notranslate nohighlight">\(U_{2}=\{(2,q_{0})\}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081635929.png" /></p>
<p>The next transition from state <span class="math notranslate nohighlight">\(2\)</span> is labelled by the push action <span class="math notranslate nohighlight">\(p(4)\)</span>, so we create the new RCG node, <span class="math notranslate nohighlight">\(q_{1}\)</span>, labelled <span class="math notranslate nohighlight">\(4\)</span> and add <span class="math notranslate nohighlight">\((8,q_{1})\)</span> to <span class="math notranslate nohighlight">\(U_{2}\)</span>. (Recall that no nodes are created in the parse tree as a result of the traversal of a push edge in the RCA.) We then read the third input symbol, <span class="math notranslate nohighlight">\(a\)</span>, traverse the edge to state <span class="math notranslate nohighlight">\(10\)</span>, create the parse tree node <span class="math notranslate nohighlight">\(w_{2}\)</span>, labelled <span class="math notranslate nohighlight">\(a\)</span>, and construct the set <span class="math notranslate nohighlight">\(U_{3}=\{(10,q_{1})\}\)</span>. From state <span class="math notranslate nohighlight">\(10\)</span>, there is a reduction transition labelled <span class="math notranslate nohighlight">\(\mathcal{R}_{3}\)</span> for rule <span class="math notranslate nohighlight">\(A::=a\)</span>. We traverse the edge to state <span class="math notranslate nohighlight">\(13\)</span> and then create the new parse tree node, <span class="math notranslate nohighlight">\(w_{3}\)</span>, labelled <span class="math notranslate nohighlight">\(A\)</span>. Since rule <span class="math notranslate nohighlight">\(3\)</span> has a right hand side of length <span class="math notranslate nohighlight">\(1\)</span>, we remove the last element from the sequence <span class="math notranslate nohighlight">\(\mathcal{W}\)</span> and use it to label the child node of <span class="math notranslate nohighlight">\(w_{3}\)</span>. We then add the new root node to the set <span class="math notranslate nohighlight">\(\mathcal{W}\)</span>, and add <span class="math notranslate nohighlight">\((13,q_{1})\)</span> to <span class="math notranslate nohighlight">\(U_{3}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081635525.png" /></p>
<p>Since state <span class="math notranslate nohighlight">\(13\)</span> contains a pop action, we find the child, <span class="math notranslate nohighlight">\(q_{0}\)</span>, of the RCG node <span class="math notranslate nohighlight">\(q_{1}\)</span>, and add <span class="math notranslate nohighlight">\((4,q_{0})\)</span> to <span class="math notranslate nohighlight">\(U_{3}\)</span>. We read the final input symbol <span class="math notranslate nohighlight">\(d\)</span>, create the new parse tree node, <span class="math notranslate nohighlight">\(w_{4}\)</span>, and construct <span class="math notranslate nohighlight">\(U_{4}\)</span> as shown below.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081635935.png" /></p>
<p>We then traverse the reduction transition, <span class="math notranslate nohighlight">\(\mathcal{R}_{2}\)</span> from state 5. Rule 2 is <span class="math notranslate nohighlight">\(A::=bAd\)</span>, so we create the new node, <span class="math notranslate nohighlight">\(w_{5}\)</span>, labelled <span class="math notranslate nohighlight">\(A\)</span>, remove the last three parse tree nodes from the sequence <span class="math notranslate nohighlight">\(\mathcal{W}\)</span> and add them to <span class="math notranslate nohighlight">\(w_{5}\)</span> as its children. We also add <span class="math notranslate nohighlight">\(w_{5}\)</span> to <span class="math notranslate nohighlight">\(\mathcal{W}\)</span> and <span class="math notranslate nohighlight">\((6,q_{0})\)</span> to <span class="math notranslate nohighlight">\(U_{4}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081636051.png" /></p>
<p>We then traverse the reduction transition, <span class="math notranslate nohighlight">\(\mathcal{R}1\)</span> from state 6 to state 7. Rule 1 is <span class="math notranslate nohighlight">\(S::=cA\)</span>, so we create the new node <span class="math notranslate nohighlight">\(w_{6}\)</span>, labelled S, remove the final two parse tree nodes from the sequence <span class="math notranslate nohighlight">\(\mathcal{W}\)</span>, and add them to <span class="math notranslate nohighlight">\(w_{6}\)</span> as its children. Since we have consumed all the input and the process <span class="math notranslate nohighlight">\((7,q_{0})\)</span> is in <span class="math notranslate nohighlight">\(U_{4}\)</span>, where 7 is the RCA’s accepting state and <span class="math notranslate nohighlight">\(q_{0}\)</span> is the base node of the RCG, the input string <span class="math notranslate nohighlight">\(cbad\)</span> is accepted by the parser. The final parse tree is shown below.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081636311.png" /></p>
<p>In the above example, the RCA is deterministic and hence there is only one derivation tree for the input string. Recall that some parses can have an exponential, or even infinite, number of derivations for a given string. We use Tomita’s SPPF representation of multiple parse trees to reduce the amount of space necessary to represent all parse trees. The next section discusses three different approaches that can be used to construct an SPPF of a parse using an RCA.</p>
</section>
<section id="constructing-an-sppf">
<h3>7.8.2 Constructing an SPPF<a class="headerlink" href="#constructing-an-sppf" title="Permalink to this heading">¶</a></h3>
<p>There are several different approaches that can be taken to construct an SPPF during a parse of the RIGLR algorithm. A straightforward technique is to store a sequence of SPPF nodes that correspond to the roots of the sub-trees that have been constructed so far with each process <span class="math notranslate nohighlight">\((k,q)\)</span>. However, since it is possible to reach a state in the RCA by traversing more than one path, this approach can significantly increase the number of processes constructed at each step of the algorithm [11].</p>
<p>An alternative approach is to merge the processes that share the same call graph nodes, so as to limit the number of processes that need to be created. Instead of storing the sequence of SPPF nodes directly in a process, we can represent the sequences of SPPF nodes in an <em>SPPF node graph</em> - a type of graph structured stack - and replace the sequence of nodes in a process by a single SPPF node graph node.</p>
<p>Unfortunately, as is shown in [15], this approach leads to spurious derivations being created in the SPPF for certain parses. Another disadvantage of using the SPPF node graph is that the structure needs to be traversed in order to construct the final SPPF, which is likely to affect the order of the parsing algorithm.</p>
<p>A solution proposed in [15] is to use special SPPF pointer nodes that point to sequences of SPPF nodes within the SPPF. To prevent the spurious derivations from being created, the edges in the call graph are labelled with these special SPPF pointer nodes. This provides a way of only associating the correct derivation sequences with their associated processes.</p>
<p>Another problem with the construction of the SPPF is caused if an existing node in the RCG, that has already had a pop applied, has a new edge added to it as a result of a push action. In Example 7.5.1 we show how the recognition algorithm deals with such cases - when a new edge is added to an existing node, all processes in <span class="math notranslate nohighlight">\(U_{i}\)</span> are checked to see if a pop was applied. Unfortunately, this approach does not simply work for the parser because we need to ensure that the correct tree is constructed for any pops that are re-applied. Thus we use the set <span class="math notranslate nohighlight">\(\mathcal{P}_{i}\)</span> to store the SPPF nodes that are associated to a pop’s reduction path. When a pop is performed, we add the sequence of SPPF nodes to a set <span class="math notranslate nohighlight">\(F\)</span> and store it in the pair <span class="math notranslate nohighlight">\((q,F)\)</span> in <span class="math notranslate nohighlight">\(\mathcal{P}_{i}\)</span>. When a push action for a process <span class="math notranslate nohighlight">\((h,q,w)\)</span> is performed, we check to see if <span class="math notranslate nohighlight">\(\mathcal{P}_{i}\)</span> contains an element of the form <span class="math notranslate nohighlight">\((q,F)\)</span>. If it does, then a pop has already been performed from state <span class="math notranslate nohighlight">\(q\)</span>. We use the sequences of SPPF nodes in <span class="math notranslate nohighlight">\(F\)</span> to add the required new processes to <span class="math notranslate nohighlight">\(U_{i}\)</span> that will cause the pops to be re-applied for the correct reduction paths.</p>
<p>Before presenting the formal description of the RIGLR parser we shall work through an example of the construction of an SPPF during a parse using the final approach discussed above. For example, consider the parse of the string <span class="math notranslate nohighlight">\(abcc\)</span>, with Grammar 7.8 and RCA shown in Figure 7.14 on page 7.14.</p>
<p>In addition to the sets <span class="math notranslate nohighlight">\(U_{i}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{P}_{i}\)</span> we maintain two additional sets during parsing. The sets <span class="math notranslate nohighlight">\(\mathcal{N}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{W}\)</span> are used to store the SPPF nodes and special pointer nodes, respectively, that are created at the current step of the algorithm. Recall from Chapter 4 that nodes in an SPPF that are labelled by the same non-terminal and derive the same portion of the input string can be merged. To achieve this efficiently, we label each SPPF node with a pair <span class="math notranslate nohighlight">\((x,j)\)</span>, where <span class="math notranslate nohighlight">\(j\)</span> is an integer representing the start position within the input string that the yield of the sub-graph <span class="math notranslate nohighlight">\((x,j)\)</span> derives. (The set <span class="math notranslate nohighlight">\(\mathcal{N}\)</span> is used to reduce the number of SPPF nodes that need to searched to find the ones that can be packed. It also allows SPPF nodes to be labelled by the pair <span class="math notranslate nohighlight">\((x,j)\)</span> since all nodes in the set will have been constructed at the current step of the algorithm.)</p>
<p>Furthermore, the SPPF of a specific <span class="math notranslate nohighlight">\(\epsilon\)</span>-rule can be shared throughout a parse whenever a reduction is done for that rule. To avoid creating redundant instances of an <span class="math notranslate nohighlight">\(\epsilon\)</span>-SPPF we shall create all <span class="math notranslate nohighlight">\(\epsilon\)</span>-SPPF’s at the start of the algorithm and use them whenever necessary.</p>
<p>Since Grammar 7.8 contains the <span class="math notranslate nohighlight">\(\epsilon\)</span>-rule <span class="math notranslate nohighlight">\(A::=\epsilon\)</span>, we build the tree, <span class="math notranslate nohighlight">\(u_{A}\)</span>, with pointer <span class="math notranslate nohighlight">\(w_{A}\)</span>. We begin the parse by creating the base node of the RCG and adding the process <span class="math notranslate nohighlight">\((0,q_{0},\epsilon)\)</span> to <span class="math notranslate nohighlight">\(U_{i}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081636155.png" /></p>
<p>We then traverse the edge labelled <span class="math notranslate nohighlight">\(\mathcal{R} 4\)</span> from state 0 to state 3 , add the process <span class="math notranslate nohighlight">\(\left(3, q_{0}, w_{A}\right)\)</span> to <span class="math notranslate nohighlight">\(U_{0}\)</span> and then traverse the push edge labelled p(4) back to state 0 . The push action results in the new RCG node, <span class="math notranslate nohighlight">\(q_{1}\)</span>, with an edge labelled <span class="math notranslate nohighlight">\(w_{A}\)</span> to <span class="math notranslate nohighlight">\(q_{0}\)</span>, being created and <span class="math notranslate nohighlight">\(\left(0, q_{1}, \epsilon\right)\)</span> being added to <span class="math notranslate nohighlight">\(U_{0}\)</span> and <span class="math notranslate nohighlight">\(\left(q_{1}, \emptyset\right)\)</span> to <span class="math notranslate nohighlight">\(\mathcal{P}_{0}\)</span>. The SPPF is not modified.
We traverse the <span class="math notranslate nohighlight">\(\mathcal{R} 4\)</span> edge again for process <span class="math notranslate nohighlight">\(\left(0, q_{1}, \epsilon\right)\)</span>, add <span class="math notranslate nohighlight">\(\left(3, q_{1}, w_{A}\right)\)</span> to <span class="math notranslate nohighlight">\(U_{0}\)</span> and then traverse the push transition <span class="math notranslate nohighlight">\(p(4)\)</span>. This results in a new edge, labelled <span class="math notranslate nohighlight">\(w_{A}\)</span>, being added to the RCG as a loop on <span class="math notranslate nohighlight">\(q_{1}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081642686.png" />
We continue the parse by reading the next input symbol, a, and then traverse the edge from state 0 to state 2 . We create the new <span class="math notranslate nohighlight">\(SPPF\)</span> node, <span class="math notranslate nohighlight">\(u_{1}\)</span>, labelled (a, 0), add a pointer node <span class="math notranslate nohighlight">\(w_{1}\)</span> to <span class="math notranslate nohighlight">\(u_{1}\)</span> and construct <span class="math notranslate nohighlight">\(U_{1}=\left\{\left(2, q_{0}, w_{1}\right),\left(2, q_{1}, w_{1}\right)\right\}\)</span>. For each of these processes we traverse the edge labelled <span class="math notranslate nohighlight">\(\mathcal{R} 3\)</span> to state 3 , create the SPPF node, <span class="math notranslate nohighlight">\(u_{2}\)</span>, labelled (A, 0) with pointer node <span class="math notranslate nohighlight">\(w_{2}\)</span>, and add the processes <span class="math notranslate nohighlight">\(\left(3, q_{0}, w_{2}\right)\)</span> and <span class="math notranslate nohighlight">\(\left(3, q_{1}, w_{2}\right)\)</span> to <span class="math notranslate nohighlight">\(U_{1}\)</span>. We add <span class="math notranslate nohighlight">\(u_{1}\)</span> as the child of <span class="math notranslate nohighlight">\(u_{2}\)</span> since we created the new SPPF node from the processes <span class="math notranslate nohighlight">\(\left(2, q_{0}, w_{1}\right),\left(2, q_{1}, w_{1}\right)\)</span>. From state 3 we traverse the edge p(4) to state 0 , create the new RCG node, <span class="math notranslate nohighlight">\(q_{2}\)</span>, and two edges labelled <span class="math notranslate nohighlight">\(w_{2}\)</span> from <span class="math notranslate nohighlight">\(q_{2}\)</span> to <span class="math notranslate nohighlight">\(q_{0}\)</span> and <span class="math notranslate nohighlight">\(q_{1}\)</span>. The process <span class="math notranslate nohighlight">\(\left(0, q_{2}, \epsilon\right)\)</span> is also added to <span class="math notranslate nohighlight">\(U_{1}\)</span> and <span class="math notranslate nohighlight">\(\left(q_{2}, \emptyset\right)\)</span> to <span class="math notranslate nohighlight">\(\mathcal{P}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081643781.png" /></p>
<p>We then traverse the edge <span class="math notranslate nohighlight">\(\mathcal{R} 4\)</span> from state 0 to state 3 for process <span class="math notranslate nohighlight">\(\left(0, q_{2}, \epsilon\right)\)</span>, followed by the push transition back to state 0 . This results in the process <span class="math notranslate nohighlight">\(\left(3, q_{2}, w_{A}\right)\)</span> being added to <span class="math notranslate nohighlight">\(U_{1}\)</span>, and the edge labelled <span class="math notranslate nohighlight">\(w_{A}\)</span> being added to the RCG from <span class="math notranslate nohighlight">\(q_{2}\)</span> to itself.<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081643781.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081643888.png" />
Traversing the edge labelled b from state 0 , we create the new SPPF node, <span class="math notranslate nohighlight">\(u_{3}\)</span>, labelled (b, 1), with pointer node <span class="math notranslate nohighlight">\(w_{3}\)</span>, and construct <span class="math notranslate nohighlight">\(U_{2}=\left\{\left(1, q_{2}, w_{3}\right)\right\}\)</span>. We then traverse the \mathcal{R} 2 edge to state 5 , create the SPPF node <span class="math notranslate nohighlight">\(u_{4}\)</span>, labelled (S, 1), with pointer node <span class="math notranslate nohighlight">\(w_{4}\)</span> and update the relevant sets as shown below.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081644300.png" />
Performing the pop action associated with state 5, for process <span class="math notranslate nohighlight">\((5,q_{2},w_{4})\)</span>, we first find the children of <span class="math notranslate nohighlight">\(q_{2}\)</span>, <span class="math notranslate nohighlight">\(q_{0},q_{1},q_{2}\)</span>. Then we create two new pointer nodes <span class="math notranslate nohighlight">\(w_{5}\)</span> and <span class="math notranslate nohighlight">\(w_{6}\)</span>, with edges to the children of the pointers of the popped edges in the RCG and <span class="math notranslate nohighlight">\(w_{4}\)</span>. For each of the new pointers we also add the processes <span class="math notranslate nohighlight">\((4,q_{0},w_{5}),(4,q_{1},w_{5})\)</span> and <span class="math notranslate nohighlight">\((4,q_{2},w_{6})\)</span> to <span class="math notranslate nohighlight">\(U_{2}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081644687.png" /></p>
<p>We continue the parse by reading the next input symbol <span class="math notranslate nohighlight">\(c\)</span> and then create the new SPPF node, <span class="math notranslate nohighlight">\(u_{5}\)</span>, labelled <span class="math notranslate nohighlight">\((c,3)\)</span>, with two pointer nodes <span class="math notranslate nohighlight">\(w_{7}\)</span> and <span class="math notranslate nohighlight">\(w_{8}\)</span>. We construct <span class="math notranslate nohighlight">\(U_{3}=\{(6,q_{0},w_{7}),(6,q_{1},w_{7}),(6,q_{2},w_{8})\}\)</span>, <span class="math notranslate nohighlight">\(\mathcal{N}=\{u_{5}\}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{W}=\{w_{7},w_{8}\}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081645842.png" />
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081645973.png" /></p>
<p>From state 6 we the traverse the <span class="math notranslate nohighlight">\(\mathcal{R}1\)</span> edge to state 5 and create two new SPP nodes <span class="math notranslate nohighlight">\(u_{9}\)</span> and <span class="math notranslate nohighlight">\(u_{10}\)</span>, labelled <span class="math notranslate nohighlight">\((S,0)\)</span> and <span class="math notranslate nohighlight">\((S,1)\)</span>, respectively. The state of the parser is shown below.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081645446.png" />
Performing the pop action associated with state 5 , for processes <span class="math notranslate nohighlight">\(\left(5, q_{1}, w_{9}\right)\)</span> and <span class="math notranslate nohighlight">\(\left(5, q_{2}, w_{10}\right)\)</span>, we first find the children of <span class="math notranslate nohighlight">\(q_{1}\)</span> and <span class="math notranslate nohighlight">\(q_{2}, q_{0}, q_{1}\)</span> and <span class="math notranslate nohighlight">\(q_{0}, q_{1}, q_{2}\)</span>. Then we create three new pointer nodes <span class="math notranslate nohighlight">\(w_{11}, w_{12}\)</span> and <span class="math notranslate nohighlight">\(w_{13}\)</span>, with edges to the children of the pointers of the popped edges in the RCG and <span class="math notranslate nohighlight">\(w_{9}\)</span> and <span class="math notranslate nohighlight">\(w_{10}\)</span> respectively. The state of the parser after the pop is complete is shown below.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081646370.png" /></p>
<p>Next we read the final input symbol <span class="math notranslate nohighlight">\(c\)</span>, create <span class="math notranslate nohighlight">\(u_{8}\)</span> labelled <span class="math notranslate nohighlight">\((c,3)\)</span> and three new pointer nodes <span class="math notranslate nohighlight">\(w_{14},w_{15}\)</span> and <span class="math notranslate nohighlight">\(w_{16}\)</span> in the SPPF. We traverse the edge from state 4 to state 6 and construct <span class="math notranslate nohighlight">\(U_{4}\)</span>.
<img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081647891.png" /></p>
<p>For each of the processes in <span class="math notranslate nohighlight">\(U_{4}\)</span> we traverse the <span class="math notranslate nohighlight">\(\mathcal{R} 1\)</span> edge from state 6 in the RCA. For processes <span class="math notranslate nohighlight">\(\left(6, q_{0},\left\{w_{14}, w_{15}\right\}\right)\)</span> and <span class="math notranslate nohighlight">\(\left(6, q_{1},\left\{w_{14}, w_{15}\right\}\right)\)</span> we create a new SPPF node, <span class="math notranslate nohighlight">\(u_{9}\)</span>, labelled (S, 0), with a pointer node <span class="math notranslate nohighlight">\(w_{17}\)</span>. Since there are two pointer nodes <span class="math notranslate nohighlight">\(w_{14}\)</span> and <span class="math notranslate nohighlight">\(w_{15}\)</span> associated with both processes, we create two packing nodes below <span class="math notranslate nohighlight">\(u_{9}\)</span>, one with edges to the children of <span class="math notranslate nohighlight">\(w_{14}\)</span> and the other with edges to the children of <span class="math notranslate nohighlight">\(w_{15}\)</span>. For <span class="math notranslate nohighlight">\(\left(6, q_{2}, w_{16}\right)\)</span> we create the new SPPF node, <span class="math notranslate nohighlight">\(u_{10}\)</span>, labelled (S, 1) with pointer node <span class="math notranslate nohighlight">\(w_{18}\)</span> and edges to the children of <span class="math notranslate nohighlight">\(w_{16}\)</span>.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081647156.png" /></p>
<p>Since the process <span class="math notranslate nohighlight">\((5,q_{0},w_{17})\)</span> is in <span class="math notranslate nohighlight">\(U_{4}\)</span>, and state <span class="math notranslate nohighlight">\(5\)</span> is the accept state of the RCA, and <span class="math notranslate nohighlight">\(q_{0}\)</span> is the base node of the RCG, the string <span class="math notranslate nohighlight">\(abcc\)</span> is accepted. We make the root node of the SPPF the node pointed to by <span class="math notranslate nohighlight">\(w_{17}\)</span>. The final SPPF, without any pointer nodes is shown below.</p>
<p><img alt="image.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081648613.png" /></p>
</section>
<section id="riglr-parser">
<h3>RIGLR parser<a class="headerlink" href="#riglr-parser" title="Permalink to this heading">¶</a></h3>
<p><img alt="Layer 4.png" src="https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310081706677.png" /></p>
</section>
</section>
<section id="summary">
<h2>7.9 Summary<a class="headerlink" href="#summary" title="Permalink to this heading">¶</a></h2>
<p>In this chapter we examined the role of the stack in bottom-up parsers and described how to construct the automata that can be used by the RIGLR recognition and parsing algorithms to parse with less stack activity than other GLR parsing techniques.
Chapter 10 contains the results of several experiments that highlight the performance of the RIGLR recognition algorithm compared to the other GLR algorithms.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="6%20Binary%20Right%20Nulled%20Generalised%20LR%20parsing.html" class="btn btn-neutral float-left" title="6.Binary Right Nulled Generalised LR parsing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="8%20Other%20approaches%20to%20generalised%20parsing.html" class="btn btn-neutral float-right" title="8 Other approaches to generalised parsing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, xrtero.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>